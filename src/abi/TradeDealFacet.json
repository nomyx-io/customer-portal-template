{
  "address": "0x678009Eb450cCfD795C7D80f82ee2BBC1F7F225e",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalInterest",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "invoicePoolInterest",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vabiInterest",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vabiTokensMinted",
          "type": "uint256"
        }
      ],
      "name": "InterestDistributedForTradeDeal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "InvoiceDepositedToTradeDeal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "InvoiceWithdrawnFromTradeDeal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "TradeDealActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vabbToVabiRatio",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "nftAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        }
      ],
      "name": "TradeDealCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "TradeDealDeactivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fundingTarget",
          "type": "uint256"
        }
      ],
      "name": "TradeDealFullyFunded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TradeDealFundingWithdrawn",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "participant",
          "type": "address"
        }
      ],
      "name": "TradeDealParticipantAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "participant",
          "type": "address"
        }
      ],
      "name": "TradeDealParticipantRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "repayer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "fullyRepaid",
          "type": "bool"
        }
      ],
      "name": "TradeDealRepaid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "claimTopics",
          "type": "uint256[]"
        }
      ],
      "name": "TradeDealRequiredClaimTopicsSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vabbToVabiRatio",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        }
      ],
      "name": "TradeDealUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        }
      ],
      "name": "USDCDepositedToTradeDeal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "USDCWithdrawnFromTradeDeal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "redeemer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "vabbAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "usdcAmount",
          "type": "uint256"
        }
      ],
      "name": "VABBTokensRedeemed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "activateTradeDeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "vabbToVabiRatio",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "requiredClaimTopics",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "fundingTarget",
          "type": "uint256"
        }
      ],
      "name": "createTradeDeal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "deactivateTradeDeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "diamondOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllTradeDealIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "getTradeDealFullStatus",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fundingTarget",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentBalance",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isFunded",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isFundingWithdrawn",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "totalDebt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "repaidAmount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isRepaid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "getTradeDealInfo",
      "outputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "vabbToVabiRatio",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "getTradeDealRequiredClaimTopics",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "getTradeDealTokenAddresses",
      "outputs": [
        {
          "internalType": "address",
          "name": "nftAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "isTradeDealFunded",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "isTradeDealParticipant",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "isTradeDealRepaid",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "vabbAmount",
          "type": "uint256"
        }
      ],
      "name": "redeemVABBTokens",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "repayTradeDeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "setTradeDealNFTAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "claimTopics",
          "type": "uint256[]"
        }
      ],
      "name": "setTradeDealRequiredClaimTopics",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        }
      ],
      "name": "setTradeDealTokenAddresses",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tdDepositInvoice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "tdDepositUSDC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "tdDistributeInterest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tdWithdrawInvoice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "tdWithdrawUSDC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "interestRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "vabbToVabiRatio",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "vabbAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vabiAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "usdcAddress",
          "type": "address"
        }
      ],
      "name": "updateTradeDeall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tradeDealId",
          "type": "uint256"
        }
      ],
      "name": "withdrawTradeDealFunding",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa09de6fa56a232061410d5395af3c0517e5528e940da9cd9aede0f207c85bef8",
  "receipt": {
    "to": null,
    "from": "0x3AAF0e6023A2745FB62052c1954260559fFF4947",
    "contractAddress": "0x678009Eb450cCfD795C7D80f82ee2BBC1F7F225e",
    "transactionIndex": 25,
    "gasUsed": "3287738",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf6ba10f73114ea8a0d8d1fc67d6edda6e51d224a92bbca0f5a4d0681dfbac5d8",
    "transactionHash": "0xa09de6fa56a232061410d5395af3c0517e5528e940da9cd9aede0f207c85bef8",
    "logs": [],
    "blockNumber": 23582236,
    "cumulativeGasUsed": "5803050",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "3e9523ba19c4c4e7f6254f024ebdfad9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invoicePoolInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vabiInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vabiTokensMinted\",\"type\":\"uint256\"}],\"name\":\"InterestDistributedForTradeDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"InvoiceDepositedToTradeDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"InvoiceWithdrawnFromTradeDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"TradeDealActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vabbToVabiRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"name\":\"TradeDealCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"TradeDealDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundingTarget\",\"type\":\"uint256\"}],\"name\":\"TradeDealFullyFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TradeDealFundingWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"TradeDealParticipantAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"TradeDealParticipantRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"repayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"fullyRepaid\",\"type\":\"bool\"}],\"name\":\"TradeDealRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"claimTopics\",\"type\":\"uint256[]\"}],\"name\":\"TradeDealRequiredClaimTopicsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vabbToVabiRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"name\":\"TradeDealUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"USDCDepositedToTradeDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"USDCWithdrawnFromTradeDeal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vabbAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdcAmount\",\"type\":\"uint256\"}],\"name\":\"VABBTokensRedeemed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"activateTradeDeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vabbToVabiRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"requiredClaimTopics\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingTarget\",\"type\":\"uint256\"}],\"name\":\"createTradeDeal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"deactivateTradeDeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"diamondOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllTradeDealIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"getTradeDealFullStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFunded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFundingWithdrawn\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repaidAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRepaid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"getTradeDealInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vabbToVabiRatio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"getTradeDealRequiredClaimTopics\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"getTradeDealTokenAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"isTradeDealFunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isTradeDealParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"isTradeDealRepaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vabbAmount\",\"type\":\"uint256\"}],\"name\":\"redeemVABBTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"repayTradeDeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"setTradeDealNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"claimTopics\",\"type\":\"uint256[]\"}],\"name\":\"setTradeDealRequiredClaimTopics\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"name\":\"setTradeDealTokenAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tdDepositInvoice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tdDepositUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"tdDistributeInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tdWithdrawInvoice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tdWithdrawUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"interestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vabbToVabiRatio\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vabbAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vabiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcAddress\",\"type\":\"address\"}],\"name\":\"updateTradeDeall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tradeDealId\",\"type\":\"uint256\"}],\"name\":\"withdrawTradeDealFunding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/TradeDealFacet.sol\":\"TradeDealFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":11},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Receiver.sol\\\";\\n\",\"keccak256\":\"0x7bd5dc796c245d4c52836610455d172cdfcc1f8dcf0d9b1c4cbde212fde02965\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/facets/TradeDealFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utilities/Modifiers.sol\\\";\\nimport \\\"../libraries/TradeDealLib.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract TradeDealFacet is Modifiers {\\n    // Events - duplicated from TradeDealLib to ensure proper EVM event emission\\n    event TradeDealCreated(\\n        uint256 indexed tradeDealId,\\n        string name,\\n        string symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        bool active,\\n        address nftAddress,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    );\\n    event TradeDealUpdated(\\n        uint256 indexed tradeDealId,\\n        string name,\\n        string symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        bool active,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    );\\n    event TradeDealActivated(uint256 indexed tradeDealId);\\n    event TradeDealDeactivated(uint256 indexed tradeDealId);\\n    event TradeDealParticipantAdded(uint256 indexed tradeDealId, address indexed participant);\\n    event TradeDealParticipantRemoved(uint256 indexed tradeDealId, address indexed participant);\\n    event InvoiceDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\\n    event InvoiceWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\\n    event USDCDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 amount, address depositor);\\n    event USDCWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 amount);\\n    event InterestDistributedForTradeDeal(uint256 indexed tradeDealId, uint256 totalInterest, uint256 invoicePoolInterest, uint256 vabiInterest, uint256 vabiTokensMinted);\\n    event TradeDealRequiredClaimTopicsSet(uint256 indexed tradeDealId, uint256[] claimTopics);\\n    // New events for enhanced functionality\\n    event TradeDealFullyFunded(uint256 indexed tradeDealId, uint256 fundingTarget);\\n    event TradeDealFundingWithdrawn(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\\n    event TradeDealRepaid(uint256 indexed tradeDealId, address indexed repayer, uint256 amount, bool fullyRepaid);\\n    event VABBTokensRedeemed(uint256 indexed tradeDealId, address indexed redeemer, uint256 vabbAmount, uint256 usdcAmount);\\n    \\n    // Single version of createTradeDeal that takes all parameters\\n    // If vabbAddress is the zero address, the VABBTokenFactoryFacet will be used to create a new VABB token\\n    // If requiredClaimTopics is empty, no claim topics will be required for participation\\n    function createTradeDeal(\\n        string memory name,\\n        string memory symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        uint256[] memory requiredClaimTopics,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress,\\n        uint256 fundingTarget\\n    ) external onlyOwner returns (uint256) {\\n        TradeDealLib.CreateTradeDealResult memory result = TradeDealLib._createTradeDeal(\\n            name,\\n            symbol,\\n            interestRate,\\n            vabbToVabiRatio,\\n            requiredClaimTopics,\\n            vabbAddress,\\n            vabiAddress,\\n            usdcAddress,\\n            fundingTarget\\n        );\\n        \\n        // Emit events with the returned data\\n        emit TradeDealCreated(\\n            result.tradeDealId,\\n            result.name,\\n            result.symbol,\\n            result.interestRate,\\n            result.vabbToVabiRatio,\\n            result.active,\\n            result.nftAddress,\\n            result.vabbAddress,\\n            result.vabiAddress,\\n            result.usdcAddress\\n        );\\n        \\n        // If claim topics were set, emit that event too\\n        if (result.hasClaimTopics) {\\n            emit TradeDealRequiredClaimTopicsSet(result.tradeDealId, result.requiredClaimTopics);\\n        }\\n        \\n        return result.tradeDealId;\\n    }\\n    \\n    function updateTradeDeall(\\n        uint256 tradeDealId,\\n        string memory name,\\n        string memory symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    ) external onlyOwner {\\n        TradeDealLib.UpdateTradeDealResult memory result = TradeDealLib._updateTradeDeal(\\n            tradeDealId,\\n            name,\\n            symbol,\\n            interestRate,\\n            vabbToVabiRatio,\\n            vabbAddress,\\n            vabiAddress,\\n            usdcAddress\\n        );\\n        \\n        // Emit event with the returned data\\n        emit TradeDealUpdated(\\n            result.tradeDealId,\\n            result.name,\\n            result.symbol,\\n            result.interestRate,\\n            result.vabbToVabiRatio,\\n            result.active,\\n            result.vabbAddress,\\n            result.vabiAddress,\\n            result.usdcAddress\\n        );\\n    }\\n    \\n    function activateTradeDeal(uint256 tradeDealId) external onlyOwner {\\n        TradeDealLib.TradeDealStateChangeResult memory result = TradeDealLib._activateTradeDeal(tradeDealId);\\n        \\n        // Emit event with the returned data\\n        emit TradeDealActivated(result.tradeDealId);\\n    }\\n    \\n    function deactivateTradeDeal(uint256 tradeDealId) external onlyOwner {\\n        TradeDealLib.TradeDealStateChangeResult memory result = TradeDealLib._deactivateTradeDeal(tradeDealId);\\n        \\n        // Emit event with the returned data\\n        emit TradeDealDeactivated(result.tradeDealId);\\n    }\\n    \\n    function getTradeDealInfo(uint256 tradeDealId) external view returns (\\n        string memory name,\\n        string memory symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        bool active\\n    ) {\\n        TradeDealLib.TradeDeal memory tradeDeal = TradeDealLib._getTradeDealInfo(tradeDealId);\\n        return (\\n            tradeDeal.name,\\n            tradeDeal.symbol,\\n            tradeDeal.interestRate,\\n            tradeDeal.vabbToVabiRatio,\\n            tradeDeal.active\\n        );\\n    }\\n    \\n    function getAllTradeDealIds() external view returns (uint256[] memory) {\\n        return TradeDealLib._getAllTradeDealIds();\\n    }\\n    \\n    function isTradeDealParticipant(uint256 tradeDealId, address user) external view returns (bool) {\\n        return TradeDealLib._isTradeDealParticipant(tradeDealId, user);\\n    }\\n    \\n    function tdDepositInvoice(uint256 tradeDealId, uint256 tokenId) external {\\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) || msg.sender == LibDiamond.contractOwner(), \\\"Not a participant in this trade deal\\\");\\n        TradeDealLib.InvoiceActionResult memory result = TradeDealLib._depositInvoiceToTradeDeal(tradeDealId, tokenId);\\n        \\n        // Emit event with the returned data\\n        emit InvoiceDepositedToTradeDeal(result.tradeDealId, result.tokenId);\\n    }\\n    \\n    function tdWithdrawInvoice(uint256 tradeDealId, uint256 tokenId) external {\\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) || msg.sender == LibDiamond.contractOwner(), \\\"Not a participant in this trade deal\\\");\\n        TradeDealLib.InvoiceActionResult memory result = TradeDealLib._withdrawInvoiceFromTradeDeal(tradeDealId, tokenId);\\n        \\n        // Emit event with the returned data\\n        emit InvoiceWithdrawnFromTradeDeal(result.tradeDealId, result.tokenId);\\n    }\\n    \\n    function tdDepositUSDC(uint256 tradeDealId, uint256 amount) external {\\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender) || msg.sender == LibDiamond.contractOwner(), \\\"Not a participant in this trade deal\\\");\\n        TradeDealLib.USDCActionResult memory result = TradeDealLib._depositUSDCToTradeDeal(tradeDealId, amount);\\n        \\n        // Emit event with the returned data\\n        emit USDCDepositedToTradeDeal(result.tradeDealId, result.amount, msg.sender);\\n        \\n        // If deposit completes the funding, emit the fully funded event too\\n        if (result.isFullyFunded) {\\n            emit TradeDealFullyFunded(result.tradeDealId, result.fundingTarget);\\n        }\\n    }\\n    \\n    function tdWithdrawUSDC(uint256 tradeDealId, uint256 amount) external onlyOwner {\\n        TradeDealLib.USDCActionResult memory result = TradeDealLib._withdrawUSDCFromTradeDeal(tradeDealId, amount);\\n        \\n        // Emit event with the returned data\\n        emit USDCWithdrawnFromTradeDeal(result.tradeDealId, result.amount);\\n    }\\n    \\n    function tdDistributeInterest(uint256 tradeDealId) external onlyOwner {\\n        TradeDealLib.InterestDistributionResult memory result = TradeDealLib._distributeInterestForTradeDeal(tradeDealId);\\n        \\n        // Emit event with the returned data\\n        emit InterestDistributedForTradeDeal(\\n            result.tradeDealId,\\n            result.totalInterest,\\n            result.invoicePoolInterest,\\n            result.vabiInterest,\\n            result.vabiTokensMinted\\n        );\\n    }\\n    \\n    // Set required claim topics for a trade deal\\n    function setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) external onlyOwner {\\n        TradeDealLib.ClaimTopicsResult memory result = TradeDealLib._setTradeDealRequiredClaimTopics(tradeDealId, claimTopics);\\n        \\n        // Emit event with the returned data\\n        emit TradeDealRequiredClaimTopicsSet(result.tradeDealId, result.claimTopics);\\n    }\\n    \\n    // Get required claim topics for a trade deal\\n    function getTradeDealRequiredClaimTopics(uint256 tradeDealId) external view returns (uint256[] memory) {\\n        return TradeDealLib._getTradeDealRequiredClaimTopics(tradeDealId);\\n    }\\n    \\n    // Set token addresses for a specific trade deal\\n    function setTradeDealTokenAddresses(\\n        uint256 tradeDealId,\\n        address /* nftAddress */, // This parameter is kept for backward compatibility but not used\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    ) external onlyOwner {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealLib.TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(TradeDealLib._tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        TradeDealLib.TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        tradeDeal.vabbAddress = vabbAddress;\\n        tradeDeal.vabiAddress = vabiAddress;\\n        tradeDeal.usdcAddress = usdcAddress;\\n    }\\n    \\n    // Get token addresses for a specific trade deal\\n    function getTradeDealTokenAddresses(uint256 tradeDealId) external view returns (\\n        address nftAddress,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    ) {\\n        TradeDealLib.TradeDeal memory tradeDeal = TradeDealLib._getTradeDealInfo(tradeDealId);\\n        return (\\n            address(this), // Return the Diamond address as the NFT address since we're using the Diamond's ERC721PermissionedTokenFacet\\n            tradeDeal.vabbAddress,\\n            tradeDeal.vabiAddress,\\n            tradeDeal.usdcAddress\\n        );\\n    }\\n    \\n    // This function is no longer needed since we're using the Diamond's ERC721PermissionedTokenFacet\\n    // Keeping it as a no-op for backward compatibility\\n    function setTradeDealNFTAddress(uint256 /* tradeDealId */, address /* nftAddress */) external onlyOwner {\\n        // No-op\\n    }\\n    \\n    // Check if a trade deal is fully funded\\n    function isTradeDealFunded(uint256 tradeDealId) external view returns (bool) {\\n        return TradeDealLib._isTradeDealFunded(tradeDealId);\\n    }\\n    \\n    // Check if a trade deal is fully repaid\\n    function isTradeDealRepaid(uint256 tradeDealId) external view returns (bool) {\\n        return TradeDealLib._isTradeDealRepaid(tradeDealId);\\n    }\\n    \\n    // Allow fundees to withdraw USDC once the trade deal is fully funded\\n    function withdrawTradeDealFunding(uint256 tradeDealId) external {\\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender), \\\"Not a participant in this trade deal\\\");\\n        TradeDealLib.FundingWithdrawalResult memory result = TradeDealLib._withdrawTradeDealFunding(tradeDealId);\\n        \\n        // Emit event with the returned data\\n        emit TradeDealFundingWithdrawn(result.tradeDealId, result.recipient, result.amount);\\n    }\\n    \\n    // Allow fundees to repay their debt\\n    function repayTradeDeal(uint256 tradeDealId, uint256 amount) external {\\n        require(TradeDealLib._isTradeDealParticipant(tradeDealId, msg.sender), \\\"Not a participant in this trade deal\\\");\\n        TradeDealLib.RepaymentResult memory result = TradeDealLib._repayTradeDeal(tradeDealId, amount);\\n        \\n        // Emit event with the returned data\\n        emit TradeDealRepaid(result.tradeDealId, result.repayer, result.amount, result.fullyRepaid);\\n    }\\n    \\n    // Allow funders to redeem their VABB tokens for USDC after the trade deal is repaid\\n    function redeemVABBTokens(uint256 tradeDealId, uint256 vabbAmount) external {\\n        TradeDealLib.VABBRedemptionResult memory result = TradeDealLib._redeemVABBTokens(tradeDealId, vabbAmount);\\n        \\n        // Emit event with the returned data\\n        emit VABBTokensRedeemed(result.tradeDealId, result.redeemer, result.vabbAmount, result.usdcAmount);\\n    }\\n    \\n    // Get comprehensive status of a trade deal\\n    function getTradeDealFullStatus(uint256 tradeDealId) external view returns (\\n        uint256 fundingTarget,\\n        uint256 currentBalance,\\n        bool isFunded,\\n        bool isFundingWithdrawn,\\n        uint256 totalDebt,\\n        uint256 repaidAmount,\\n        bool isRepaid\\n    ) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealLib.TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(TradeDealLib._tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\\n        currentBalance = tds.tradeDealUsdcBalances[tradeDealId];\\n        isFunded = TradeDealLib._isTradeDealFunded(tradeDealId);\\n        isFundingWithdrawn = tds.tradeDealFundingWithdrawn[tradeDealId];\\n        totalDebt = tds.tradeDealTotalDebt[tradeDealId];\\n        repaidAmount = tds.tradeDealRepaidAmounts[tradeDealId];\\n        isRepaid = TradeDealLib._isTradeDealRepaid(tradeDealId);\\n    }\\n}\",\"keccak256\":\"0x231ad65f803118a37d9b03a0cbc33fcd476c67be986ad1509ec00fd0484a7529\",\"license\":\"MIT\"},\"contracts/identity/IdentityStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721A.sol\\\";\\nimport {TrustedIssuer} from \\\"../interfaces/ITrustedIssuersRegistry.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport {IIdentity} from \\\"../interfaces/IIdentity.sol\\\";\\nimport {Claim} from \\\"../interfaces/IClaim.sol\\\";\\nimport \\\"../interfaces/IMarketplace.sol\\\";\\nimport \\\"../libraries/TradeDealLib.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary IdentitySystemStorage {\\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\\n    using Address for address;\\n\\n    // VabbleStorage struct definition\\n    struct VabbleStorage {\\n        address nft;\\n        address invoicePool;\\n        address vabb;\\n        address usdcPool;\\n        address vabi;\\n        uint256 interestRate;\\n        uint256 vabbToVabiRatio;\\n    }\\n\\n    error ApprovalCallerNotOwnerNorApproved();\\n    error ApprovalQueryForNonexistentToken();\\n    error ApproveToCaller();\\n    error ApprovalToCurrentOwner();\\n    error BalanceQueryForZeroAddress();\\n    error MintedQueryForZeroAddress();\\n    error BurnedQueryForZeroAddress();\\n    error AuxQueryForZeroAddress();\\n    error MintToZeroAddress();\\n    error MintZeroQuantity();\\n    error OwnerIndexOutOfBounds();\\n    error OwnerQueryForNonexistentToken();\\n    error TokenIndexOutOfBounds();\\n    error TransferCallerNotOwnerNorApproved();\\n    error TransferFromIncorrectOwner();\\n    error TransferToNonERC721ReceiverImplementer();\\n    error TransferToZeroAddress();\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    struct IdentitySystem {\\n        // ERC721A storage\\n        ERC721AContract erc721Contract;\\n        // TrustedIssuer storage\\n        mapping(address => TrustedIssuer) trustedIssuers;\\n        address[] trustedIssuerAddresses;\\n        mapping(address => mapping(uint256 => bool)) trustedIssuerClaimTopics;\\n        mapping(address => uint256[]) trustedIssuerClaimTopicsList;\\n        mapping(uint256 => bool) topics;\\n        uint256[] topicList;\\n        // Identity storage\\n        mapping(address => address) identities;\\n        mapping(address => address) identityOwnersMap;\\n        address[] identityOwners;\\n        // Claim storage\\n        mapping(address => mapping(uint256 => uint256)) claims;\\n        mapping(address => uint256[]) claimList;\\n        // Claim storage\\n        mapping(uint256 => Claim) tokenClaims;\\n        Claim[] tokenClaimList;\\n        // ERC721Permissioned storage\\n        address delegatedMinter;\\n        mapping(uint256 => bool) frozen;\\n\\n        uint256 itemIds;\\n        uint256 itemsSold;\\n        mapping(uint256 => MarketItem) idToMarketItem;\\n        mapping(uint256 => bool) idToListed;\\n        MarketItem[] items;\\n        \\n        // Vabble storage\\n        VabbleStorage vabbleStorage;\\n        \\n        // Trade Deal storage\\n        TradeDealLib.TradeDealStorage tradeDealStorage;\\n    }\\n\\n    bytes32 constant IDENTITY_SYSTEM_STORAGE_POSITION =\\n        keccak256(\\\"diamond.identity.system.storage\\\");\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (IdentitySystemStorage.IdentitySystem storage ds)\\n    {\\n        bytes32 position = IDENTITY_SYSTEM_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function _tokenExists(\\n        IdentitySystem storage self,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        return self.erc721Contract._ownerships[_tokenId].addr != address(0);\\n    }\\n\\n    function _getIdentity(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (address addr) {\\n        return self.identities[_userAddress];\\n    }\\n\\n    function getIdentityOwner(\\n        IdentitySystem storage self,\\n        address _identity\\n    ) internal view returns (address) {\\n        return self.identityOwnersMap[_identity];\\n    }\\n\\n    function isIdentityAddress(\\n        IdentitySystem storage self,\\n        address _identity\\n    ) internal view returns (bool) {\\n        return self.identityOwnersMap[_identity] != address(0);\\n    }\\n\\n    function isRegistered(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (bool) {\\n        return self.identities[_userAddress] != address(0);\\n    }\\n\\n    function isIdentityOwner(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (bool) {\\n        return\\n            self.identityOwnersMap[self.identities[_userAddress]] ==\\n            _userAddress;\\n    }\\n\\n    // trusted issuer\\n\\n    function isTrustedIssuer(\\n        IdentitySystem storage self,\\n        address _issuer\\n    ) internal view returns (bool) {\\n        return self.trustedIssuers[_issuer].claimIssuer != address(0);\\n    }\\n\\n    function addTrustedIssuer(\\n        IdentitySystem storage self,\\n        address _trustedIssuer,\\n        uint[] calldata _claimTopics\\n    ) internal {\\n        self.trustedIssuers[_trustedIssuer] = TrustedIssuer({\\n            claimIssuer: _trustedIssuer,\\n            claimTopics: _claimTopics\\n        });\\n        self.trustedIssuerAddresses.push(_trustedIssuer);\\n    }\\n\\n    function removeTrustedIssuer(\\n        IdentitySystem storage self,\\n        address _trustedIssuer\\n    ) internal {\\n        delete self.trustedIssuers[_trustedIssuer];\\n        for (uint256 i = 0; i < self.trustedIssuerAddresses.length; i++) {\\n            if (self.trustedIssuerAddresses[i] == _trustedIssuer) {\\n                self.trustedIssuerAddresses[i] = self.trustedIssuerAddresses[\\n                    self.trustedIssuerAddresses.length - 1\\n                ];\\n                self.trustedIssuerAddresses.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    // claim topics\\n\\n    function addClaimTopic(\\n        IdentitySystem storage self,\\n        uint256 _claimTopic\\n    ) internal {\\n        self.topics[_claimTopic] = true;\\n        self.topicList.push(_claimTopic);\\n    }\\n\\n    function removeClaimTopic(\\n        IdentitySystem storage self,\\n        uint256 _claimTopic\\n    ) internal {\\n        delete self.topics[_claimTopic];\\n        for (uint256 i = 0; i < self.topicList.length; i++) {\\n            if (self.topicList[i] == _claimTopic) {\\n                self.topicList[i] = self.topicList[self.topicList.length - 1];\\n                self.topicList.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function getClaimTopics(\\n        IdentitySystem storage self\\n    ) internal view returns (uint256[] memory) {\\n        return self.topicList;\\n    }\\n\\n    function hasClaimTopic(\\n        IdentitySystem storage self,\\n        uint256 _claimTopic\\n    ) internal view returns (bool) {\\n        return self.topics[_claimTopic];\\n    }\\n\\n    // trusted issuer / claim topics\\n\\n    function updateIssuerClaimTopics(\\n        IdentitySystem storage self,\\n        address _trustedIssuer,\\n        uint[] calldata _claimTopics\\n    ) internal {\\n        self.trustedIssuers[_trustedIssuer].claimTopics = _claimTopics;\\n        for (\\n            uint256 i = 0;\\n            i < self.trustedIssuerClaimTopicsList[_trustedIssuer].length;\\n            i++\\n        ) {\\n            delete self.trustedIssuerClaimTopics[_trustedIssuer][\\n                self.trustedIssuerClaimTopicsList[_trustedIssuer][i]\\n            ];\\n        }\\n    }\\n\\n    function addTrustedIssuerClaimTopic(\\n        IdentitySystem storage self,\\n        address _issuer,\\n        uint _claimTopic\\n    ) internal {\\n        self.trustedIssuerClaimTopics[_issuer][_claimTopic] = true;\\n        self.trustedIssuerClaimTopicsList[_issuer].push(_claimTopic);\\n    }\\n\\n    function removeTrustedIssuerClaimTopic(\\n        IdentitySystem storage self,\\n        address _issuer,\\n        uint _claimTopic\\n    ) internal {\\n        delete self.trustedIssuerClaimTopics[_issuer][_claimTopic];\\n        for (\\n            uint256 i = 0;\\n            i < self.trustedIssuerClaimTopicsList[_issuer].length;\\n            i++\\n        ) {\\n            if (self.trustedIssuerClaimTopicsList[_issuer][i] == _claimTopic) {\\n                self.trustedIssuerClaimTopicsList[_issuer][i] = self\\n                    .trustedIssuerClaimTopicsList[_issuer][\\n                        self.trustedIssuerClaimTopicsList[_issuer].length - 1\\n                    ];\\n                self.trustedIssuerClaimTopicsList[_issuer].pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    modifier isTrustedIssuerForClaimTopic(uint256 _claimTopic) {\\n        IdentitySystem storage _storage = IdentitySystemStorage.diamondStorage();\\n        require(_storage.isTrustedIssuer(msg.sender), \\\"Not a trusted issuer\\\");\\n        require(\\n            _storage.hasTrustedIssuerClaimTopic(msg.sender, _claimTopic),\\n            \\\"Issuer not authorized for claim topic\\\"\\n        );\\n        _;\\n    }\\n\\n    function hasTrustedIssuerClaimTopic(\\n        IdentitySystem storage self,\\n        address _issuer,\\n        uint256 _claimTopic\\n    ) internal view returns (bool) {\\n        if (!self.isTrustedIssuer(_issuer)) return false;\\n        uint256[] storage claimTopics = self\\n            .trustedIssuers[_issuer]\\n            .claimTopics;\\n        for (uint256 i = 0; i < claimTopics.length; i++) {\\n            if (claimTopics[i] == _claimTopic) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function addIdentity(\\n        IdentitySystem storage self,\\n        address _userAddress,\\n        address _identity\\n    ) internal {\\n        self.identities[_userAddress] = _identity;\\n        self.identityOwners.push(_userAddress);\\n        self.identityOwnersMap[_identity] = _userAddress;\\n    }\\n\\n    function removeIdentity(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal {\\n        delete self.identities[_userAddress];\\n        for (uint256 i = 0; i < self.identityOwners.length; i++) {\\n            if (self.identityOwners[i] == _userAddress) {\\n                self.identityOwners[i] = self.identityOwners[\\n                    self.identityOwners.length - 1\\n                ];\\n                self.identityOwners.pop();\\n                self.identityOwnersMap[self.identities[_userAddress]] = address(\\n                    0\\n                );\\n                break;\\n            }\\n        }\\n    }\\n\\n    function hasIdentity(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (bool) {\\n        address identity = self.identities[_userAddress];\\n        return identity != address(0);\\n    }\\n\\n    function hasClaims(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (bool) {\\n        return self.identities[_userAddress] != address(0);\\n    }\\n\\n    function isVerified(\\n        IdentitySystem storage self,\\n        address _userAddress\\n    ) internal view returns (bool) {\\n        return hasIdentity(self, _userAddress) && hasClaims(self, _userAddress);\\n    }\\n\\n    /**\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(\\n        IdentitySystem storage self,\\n        address msgSender,\\n        address to,\\n        uint256 quantity,\\n        bytes memory _data,\\n        bool safe\\n    ) internal {\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        uint256 startTokenId = self.erc721Contract._currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n\\n        self._beforeTokenTransfer(address(0), to, startTokenId, true);\\n\\n        unchecked {\\n        \\n            self.erc721Contract._addressData[to].balance += uint64(quantity);\\n            self.erc721Contract._addressData[to].numberMinted += uint64(quantity);\\n\\n            self.erc721Contract._ownerships[startTokenId].addr = to;\\n            self.erc721Contract._ownerships[startTokenId].startTimestamp = uint64(\\n                block.timestamp\\n            );\\n\\n            uint256 updatedIndex = startTokenId;\\n\\n            // log quantity\\n            console.log(\\\"Minting %s tokens to %s\\\", quantity, to);\\n\\n            for (uint256 i; i < quantity; i++) {\\n                emit Transfer(address(0), to, updatedIndex);\\n                if (\\n                    safe &&\\n                    !_checkOnERC721Received(\\n                        msgSender,\\n                        address(0),\\n                        to,\\n                        updatedIndex,\\n                        _data\\n                    )\\n                ) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                }\\n                console.log(\\\"Minted token %s to %s\\\", updatedIndex, to);\\n                self.erc721Contract._currentIndex = updatedIndex + 1;\\n                updatedIndex++;\\n            }\\n        }\\n\\n        _afterTokenTransfer(self, address(0), to, startTokenId, quantity);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(\\n        IdentitySystem storage self,\\n        address owner\\n    ) internal view returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return uint256(self.erc721Contract._addressData[owner].balance);\\n    }\\n\\n    /**\\n     * Returns the number of tokens minted by `owner`.\\n     */\\n    function _numberMinted(\\n        IdentitySystem storage self,\\n        address owner\\n    ) internal view returns (uint256) {\\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\\n        return uint256(self.erc721Contract._addressData[owner].numberMinted);\\n    }\\n\\n    /**\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\n     */\\n    function _numberBurned(\\n        IdentitySystem storage self,\\n        address owner\\n    ) internal view returns (uint256) {\\n        if (owner == address(0)) revert BurnedQueryForZeroAddress();\\n        return uint256(self.erc721Contract._addressData[owner].numberBurned);\\n    }\\n\\n    /**\\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     */\\n    function _getAux(\\n        IdentitySystem storage self,\\n        address owner\\n    ) internal view returns (uint64) {\\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\\n        return self.erc721Contract._addressData[owner].aux;\\n    }\\n\\n    /**\\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\\n     * If there are multiple variables, please pack them into a uint64.\\n     */\\n    function _setAux(\\n        IdentitySystem storage self,\\n        address owner,\\n        uint64 aux\\n    ) internal {\\n        if (owner == address(0)) revert AuxQueryForZeroAddress();\\n        self.erc721Contract._addressData[owner].aux = aux;\\n    }\\n\\n    function ownershipOf(\\n        IdentitySystem storage self,\\n        uint256 tokenId\\n    ) internal view returns (TokenOwnership memory) {\\n        uint256 curr = tokenId;\\n        unchecked {\\n            if (curr < self.erc721Contract._currentIndex) {\\n                TokenOwnership memory ownership = self.erc721Contract._ownerships[curr];\\n                if (!ownership.burned) {\\n                    if (ownership.addr != address(0)) {\\n                        return ownership;\\n                    }\\n                    // Invariant:\\n                    // There will always be an ownership that has an address and is not burned\\n                    // before an ownership that does not have an address and is not burned.\\n                    // Hence, curr will not underflow.\\n                    while (true) {\\n                        curr--;\\n                        ownership = self.erc721Contract._ownerships[curr];\\n                        if (ownership.addr != address(0)) {\\n                            return ownership;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        revert OwnerQueryForNonexistentToken();\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(\\n        IdentitySystem storage self,\\n        uint256 tokenId\\n    ) internal view returns (bool) {\\n        return\\n            tokenId < self.erc721Contract._currentIndex && !self.erc721Contract._ownerships[tokenId].burned;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(\\n        IdentitySystem storage self,\\n        uint256 tokenId\\n    ) internal view returns (address) {\\n        if (!_exists(self, tokenId)) revert ApprovalQueryForNonexistentToken();\\n        return self.erc721Contract._tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(\\n        IdentitySystem storage self,\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        self.erc721Contract._operatorApprovals[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(\\n        IdentitySystem storage self,\\n        address owner,\\n        address operator\\n    ) internal view returns (bool) {\\n        return self.erc721Contract._operatorApprovals[owner][operator];\\n    }\\n\\n    function currentIndex(\\n        IdentitySystem storage self\\n    ) internal view returns (uint256) {\\n        return self.erc721Contract._currentIndex;\\n    }\\n    \\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        IdentitySystem storage self,\\n        address msgSender,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bool _force\\n    ) internal {\\n        TokenOwnership memory prevOwnership = self.ownershipOf(tokenId);\\n\\n        bool isApprovedOrOwner = (msgSender == prevOwnership.addr ||\\n            self.isApprovedForAll(prevOwnership.addr, msgSender) ||\\n            self.getApproved(tokenId) == msgSender);\\n\\n        if (!isApprovedOrOwner && !_force)\\n            revert TransferCallerNotOwnerNorApproved();\\n        if (prevOwnership.addr != from && !_force) revert TransferFromIncorrectOwner();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        self._beforeTokenTransfer(from, to, tokenId, _force);\\n\\n        if (from == address(0)) {\\n            self._addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            self._removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            self._removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            self._addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n\\n        // Clear approvals from the previous owner\\n        self._approve(address(0), tokenId, prevOwnership.addr);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            self.erc721Contract._addressData[from].balance -= 1;\\n            self.erc721Contract._addressData[to].balance += 1;\\n\\n            self.erc721Contract._ownerships[tokenId].addr = to;\\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId < self.erc721Contract._currentIndex) {\\n                    self.erc721Contract._ownerships[nextTokenId].addr = prevOwnership.addr;\\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = prevOwnership\\n                        .startTimestamp;\\n                }\\n            }\\n        }\\n        \\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfer(self, from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(IdentitySystem storage self, uint256 tokenId) internal {\\n        TokenOwnership memory prevOwnership = ownershipOf(self, tokenId);\\n\\n        self._beforeTokenTransfer(prevOwnership.addr, address(0), tokenId, true);\\n\\n        // Clear approvals from the previous owner\\n        _approve(self, address(0), tokenId, prevOwnership.addr);\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            self.erc721Contract._addressData[prevOwnership.addr].balance -= 1;\\n            self.erc721Contract._addressData[prevOwnership.addr].numberBurned += 1;\\n\\n            // Keep track of who burned the token, and the timestamp of burning.\\n            self.erc721Contract._ownerships[tokenId].addr = prevOwnership.addr;\\n            self.erc721Contract._ownerships[tokenId].startTimestamp = uint64(block.timestamp);\\n            self.erc721Contract._ownerships[tokenId].burned = true;\\n\\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.\\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\\n            uint256 nextTokenId = tokenId + 1;\\n            if (self.erc721Contract._ownerships[nextTokenId].addr == address(0)) {\\n                // This will suffice for checking _exists(nextTokenId),\\n                // as a burned slot cannot contain the zero address.\\n                if (nextTokenId < self.erc721Contract._currentIndex) {\\n                    self.erc721Contract._ownerships[nextTokenId].addr = prevOwnership.addr;\\n                    self.erc721Contract._ownerships[nextTokenId].startTimestamp = prevOwnership\\n                        .startTimestamp;\\n                }\\n            }\\n        }\\n\\n        self._removeTokenFromOwnerEnumeration(msg.sender, tokenId);\\n        self._removeTokenFromAllTokensEnumeration(tokenId);\\n\\n        emit Transfer(prevOwnership.addr, address(0), tokenId);\\n        _afterTokenTransfer(self, prevOwnership.addr, address(0), tokenId, 1);\\n\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {\\n            self.erc721Contract._burnCounter++;\\n        }\\n    }\\n\\n    function exists(IdentitySystem storage self, uint256 tokenId) internal view returns (bool) {\\n        return _exists(self, tokenId);\\n    }\\n\\n\\n    function setTokenClaimTopics(IdentitySystem storage self, uint256 tokenId, uint256[] memory claimTopics) internal {\\n        require(self.exists(tokenId), \\\"ERC721: token does not exist\\\");\\n        for (uint256 i = 0; i < claimTopics.length; i++) {\\n            self.tokenClaims[tokenId] = Claim({\\n                topic: claimTopics[i],\\n                scheme: 0,\\n                issuer: address(this),\\n                signature: \\\"\\\",\\n                data: \\\"\\\",\\n                uri: \\\"\\\"\\n            });\\n        }\\n    }\\n\\n    function getTokenClaimTopics(uint256 tokenId) public view returns (Claim[] memory) {\\n        IdentitySystemStorage.IdentitySystem storage identitySystem = IdentitySystemStorage.diamondStorage();\\n        require(identitySystem._exists(tokenId), \\\"ERC721: token does not exist\\\");\\n        Claim[] memory claimTopics = new Claim[](identitySystem.tokenClaimList.length);\\n        for (uint256 i = 0; i < identitySystem.tokenClaimList.length; i++) {\\n            claimTopics[i] = identitySystem.tokenClaims[tokenId];\\n        }\\n        return claimTopics;\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(\\n        IdentitySystem storage self,\\n        address to,\\n        uint256 tokenId,\\n        address owner\\n    ) internal {\\n        self.erc721Contract._tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    function _ownerOf(\\n        IdentitySystem storage self,\\n        uint256 tokenId\\n    ) internal view returns (address) {\\n        return ownershipOf(self, tokenId).addr;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address msgSender,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        if (to.isContract()) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msgSender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function tokensOfOwner(\\n        IdentitySystem storage self,\\n        address owner\\n    ) internal view returns (uint256[] memory) {\\n        require(owner != address(0), \\\"IdentityStorage: owner query for zero address\\\");\\n        \\n        uint256 ownerTokenCount = IERC721(address(this)).balanceOf(owner);\\n        if (ownerTokenCount == 0) {\\n            // Return an empty array\\n            return new uint256[](0);\\n        }\\n        \\n        uint256[] memory tokens = new uint256[](ownerTokenCount);\\n        for (uint256 i = 0; i < ownerTokenCount; i++) {\\n            tokens[i] = self.erc721Contract._ownedTokens[owner][i];\\n        }\\n        \\n        return tokens;\\n    }\\n\\n    function tokenOfOwnerByIndex(\\n        IdentitySystem storage self,\\n        address owner, \\n        uint256 index) internal view returns (uint256) {\\n        require(index < IERC721(address(this)).balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return self.erc721Contract._ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply(\\n        IdentitySystem storage self\\n    ) internal view returns (uint256) {\\n        return self.erc721Contract._allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(\\n        IdentitySystem storage self,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        require(index < totalSupply(self), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return self.erc721Contract._allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(\\n        IdentitySystem storage self,\\n        address to, \\n        uint256 tokenId) internal {\\n        uint256 length = IERC721(address(this)).balanceOf(to);\\n        self.erc721Contract._ownedTokens[to][length] = tokenId;\\n        self.erc721Contract._ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(\\n        IdentitySystem storage self,\\n        uint256 tokenId) internal {\\n        self.erc721Contract._allTokensIndex[tokenId] = self.erc721Contract._allTokens.length + 1;\\n        self.erc721Contract._allTokens.push(tokenId);\\n    }\\n\\n    function _getIdentityAddress(IdentitySystem storage self, address _address) internal view returns (address) {\\n        address identityAddress = self._getIdentity(_address);\\n        return identityAddress != address(0) ? identityAddress : _address;\\n    }\\n\\n    function _hasClaim(IdentitySystem storage self, address _address, uint256 _claimTopic) internal view returns (bool) {\\n        address idObj = self._getIdentityAddress(_address);\\n        for (uint256 i = 0; i < self.claimList[idObj].length; i++) {\\n            if (self.claimList[idObj][i] == _claimTopic) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(\\n        IdentitySystem storage self,\\n        address from,\\n        uint256 tokenId\\n    ) internal {\\n        address owner = IERC721(address(this)).ownerOf(tokenId);\\n        address thisAddress = address(this);\\n\\n        console.log(\\\"owner:\\\", owner);\\n        console.log(\\\"this:\\\", thisAddress);\\n\\n        // require(owner == thisAddress, \\\"ERC721: transfer of token that is not own\\\");\\n        uint256 lastTokenIndex = IERC721(thisAddress).balanceOf(from) - 1; \\n        uint256 tokenIndex = self.erc721Contract._ownedTokensIndex[tokenId];\\n\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = self.erc721Contract._ownedTokens[from][lastTokenIndex];\\n\\n            self.erc721Contract._ownedTokens[from][tokenIndex] = lastTokenId;\\n            self.erc721Contract._ownedTokensIndex[lastTokenId] = tokenIndex;\\n        }\\n\\n        delete self.erc721Contract._ownedTokensIndex[tokenId];\\n        delete self.erc721Contract._ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(\\n        IdentitySystem storage self,\\n        uint256 tokenId\\n    ) internal {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n        uint256 lastTokenIndex = self.erc721Contract._allTokens.length - 1;\\n        uint256 tokenIndex = self.erc721Contract._allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = self.erc721Contract._allTokens[lastTokenIndex];\\n\\n        self.erc721Contract._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        self.erc721Contract._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete self.erc721Contract._allTokensIndex[tokenId];\\n        self.erc721Contract._allTokens.pop();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\\n     * And also called before burning one token.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        IdentitySystem storage self,\\n        address from,\\n        address to,\\n        uint256,\\n        bool force\\n    ) internal view {\\n        console.log(\\\"_beforeTokenTransfers called\\\");\\n        console.log(\\\"from: \\\", from);\\n        console.log(\\\"to: \\\", to);\\n        if (force) {\\n            console.log(\\\"forced\\\");\\n            return;\\n        }\\n\\n        // Allow transfers from or to the contract itself without additional checks\\n        if (from == address(this) || to == address(this)) {\\n            console.log(\\n                \\\"Transfer involves the contract itself, skipping checks\\\"\\n            );\\n            return;\\n        }\\n\\n        bool hasCommonClaim = false;\\n        uint256 claimType = 1; // Start from claim type 1\\n\\n        while (!hasCommonClaim) {\\n            bool hasFromClaim = self._hasClaim(from, claimType) ||\\n                from == address(this);\\n            if (hasFromClaim && self._hasClaim(to, claimType)) {\\n                hasCommonClaim = true;\\n            } else {\\n                claimType++;\\n                if (claimType == 0) {\\n                    // Overflow, we've checked all possible claim types\\n                    break;\\n                }\\n            }\\n        }\\n\\n        require(\\n            hasCommonClaim,\\n            \\\"ERC721: sender and receiver do not have a common claim\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\\n     * minting.\\n     * And also called after one token has been burned.\\n     *\\n     * startTokenId - the first token id to be transferred\\n     * quantity - the amount to be transferred\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\n     * - `from` and `to` are never both zero.\\n     */\\n    function _afterTokenTransfer(\\n        IdentitySystem storage self,\\n        address from,\\n        address to,\\n        uint256 startTokenId,\\n        uint256 quantity\\n    ) internal {}\\n}\\n\",\"keccak256\":\"0xd9c753b7b44f5317201e3a49a100486450a62e3887dfb10bc32da9315fabf2ef\",\"license\":\"MIT\"},\"contracts/interfaces/IClaim.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nstruct Claim {\\n    uint256 topic;\\n    uint256 scheme;\\n    address issuer;\\n    bytes signature;\\n    bytes data;\\n    string uri;\\n}\",\"keccak256\":\"0xb104f9f6208a657a595ec893c71f3393e192919b918f51ebd8727ecdffdaadc8\",\"license\":\"MIT\"},\"contracts/interfaces/IClaimIssuer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IIdentity.sol\\\";\\n\\nstruct Claim {\\n    uint256 topic;\\n    uint256 scheme;\\n    address issuer;\\n    bytes signature;\\n    bytes data;\\n    string uri;\\n    bool isRemoved;\\n}\\n\\ninterface IClaimIssuer is IIdentity {\\n\\n    event ClaimRevoked(bytes indexed signature);\\n\\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\\n    function revokeClaimBySignature(bytes calldata signature) external;\\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\\n    function isClaimValid(\\n        IIdentity _identity,\\n        uint256 claimTopic,\\n        bytes calldata sig,\\n        bytes calldata data)\\n    external view returns (bool);\\n    function getRecoveredAddress(bytes calldata sig, bytes32 dataHash) external pure returns (address);\\n    \\n}\",\"keccak256\":\"0xf94927c44289cafe7442ff3e69f6949f3f97ab784a27b0b5d79f3757da7f1dd8\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\",\"keccak256\":\"0x07ab94171f8bf7530b1925a870887671702c22cdebe78952c9dda46eaad01c54\",\"license\":\"MIT\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x65006dc04090531acd9805684a1f27252b8abb0c1990fcf0ba8db33f50791a0d\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721A.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/* solhint-disable indent */\\n\\n// Compiler will pack this into a single 256bit word.\\nstruct TokenOwnership {\\n    address addr; // The address of the owner.\\n    uint64 startTimestamp; // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n    bool burned; // Whether the token has been burned.\\n}\\n\\n// Compiler will pack this into a single 256bit word.\\nstruct AddressData {\\n    \\n    uint64 balance; // Realistically, 2**64-1 is more than enough.\\n    uint64 numberMinted; // Keeps track of mint count with minimal overhead for tokenomics.\\n    uint64 numberBurned; // Keeps track of burn count with minimal overhead for tokenomics.\\n    // For miscellaneous variable(s) pertaining to the address\\n    // (e.g. number of whitelist mint slots used).\\n    // If there are multiple variables, please pack them into a uint64.\\n    uint64 aux;\\n}\\n\\nstruct ERC721AContract {\\n    // The tokenId of the next token to be minted.\\n    uint256 _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 _burnCounter;\\n\\n    // Token name\\n    string _name;\\n\\n    // Token symbol\\n    string _symbol;\\n\\n    // the base uri\\n    string __uri;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\\n    mapping(uint256 => TokenOwnership) _ownerships;\\n\\n    // Mapping owner address to address data\\n    mapping(address => AddressData) _addressData;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) _operatorApprovals;\\n    \\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) _allTokensIndex;\\n}\\n\",\"keccak256\":\"0xc93162a8658643d377f28a9d0f79f7fa4269ada3504d490dfdd7f544671dda1a\",\"license\":\"MIT\"},\"contracts/interfaces/IERC721Permissioned.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface IERC721Permissioned {\\n\\n    event TransferForced(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event DelegatedMinterSet(address indexed newDelegatedMinter);\\n    event Mint(address indexed to, uint256 indexed tokenId);\\n    event Burn(address indexed from, uint256 indexed tokenId);\\n    event Freeze(address indexed from, uint256 indexed tokenId);\\n    event FreezeBatch(address indexed from, uint256[] tokenIds);\\n    event Release(address indexed from, uint256 indexed tokenId);\\n\\n    // force a transfer from the user to the to address irrepective of registry\\n    // TODO: Does this mean that the transfer will go even if both addresses aren't\\n    //      registered? If so, this is a security issue.\\n    function forcedTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external returns (bool);\\n\\n    function setDelegatedMinter(address _newDelegatedMinter) external returns (bool);\\n    function delegatedMinter() external view returns (address);\\n\\n    function mint(address _to, bytes calldata data) external returns (uint256);\\n    function burn(uint256 _tokenId) external returns (bool);\\n\\n    function freeze(uint256 tokenID) external;\\n    function release(uint256 tokenID) external;\\n\\n}\\n\",\"keccak256\":\"0xb3f9c69ddfc01e8fb43822dbab1c213a7719ae09f1edc0bbdd5def2f85dc469d\",\"license\":\"MIT\"},\"contracts/interfaces/IERC734.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from \\\"./IERC165.sol\\\";\\n\\ninterface IERC734 is IERC165 {\\n    // events\\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n    event ExecutionRequested(\\n        uint256 indexed executionId,\\n        address indexed to,\\n        uint256 indexed value,\\n        bytes data\\n    );\\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n    event Approved(uint256 indexed executionId, bool approved);\\n\\n    // functions\\n    // setters\\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external;\\n    function removeKey(bytes32 _key, uint256 _purpose) external;\\n    function approve(uint256 _id, bool _approve) external;\\n\\n    // getters\\n    function getKey(bytes32 _key) external view returns(uint256[] memory purposes, uint256 keyType, bytes32 key);\\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory);\\n    function getKeysByPurpose(uint256 _purpose) external view returns(bytes32[] memory);\\n    function getExecution(uint256 _id) external view returns(address to, uint256 value, bytes memory data, bool approved, uint256 executionType);\\n}\\n\",\"keccak256\":\"0xa1bbf071037ac2d697a9134e90ac01a4ca93b206d15283182d8d01f7edda46c0\",\"license\":\"GPL-3.0\"},\"contracts/interfaces/IERC735.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IERC735 {\\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\\n\\n    function getClaim(bytes32 _claimId) external returns(uint256 topic, uint256 scheme, address issuer, bytes memory signature, bytes memory data, string memory uri);\\n    function getClaimIdsByTopic(uint256 _topic) external returns(bytes32[] memory claimIds);\\n    function addClaim(\\n        uint256 _topic, \\n        uint256 _scheme, \\n        address _issuer, \\n        bytes memory _signature, \\n        bytes memory _data, \\n        string memory _uri) external returns (uint256 claimRequestId);\\n    function changeClaim(bytes32 _claimId, uint256 _topic, uint256 _scheme, address _issuer, bytes memory _signature, bytes memory _data, string memory _uri) external returns (bool success);\\n    function removeClaim(bytes32 _claimId) external returns (bool success);\\n}\\n\\n/*\\nHow IdentityRegistry works:\\n\\n1. User creates an Identity contract\\n2. User calls IdentityRegistry.addIdentity(address _identity, IIdentity identityData)\\n3. IdentityRegistry emits IdentityAdded(address indexed _address, IIdentity identity)\\n4. IdentityRegistry emits ClaimAdded(address indexed identity, uint256 indexed claimTopic, bytes claim)\\n5. IdentityRegistry emits WalletLinked(address indexed walletAddress, bytes32 indexed onchainID)\\n\\n*/\",\"keccak256\":\"0xd9696a4c45abd2c8e0cc7cd8f02bd18612d0dcb0c573c928ab225de624c01d92\",\"license\":\"MIT\"},\"contracts/interfaces/IIdentity.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IERC734 } from \\\"./IERC734.sol\\\";\\nimport { IERC735 } from \\\"./IERC735.sol\\\";\\n\\ninterface IIdentity is IERC734, IERC735 {\\n    function isVerified() external view returns (bool);\\n    function getClaimTopics() external view returns (uint256[] memory);\\n}\",\"keccak256\":\"0x3441179ea9b419fccd103fa16dad25300acb771897159f124aeb816d93552044\",\"license\":\"MIT\"},\"contracts/interfaces/IInvoicePool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IInvoicePool {\\n    function depositInvoice(uint256 tokenId) external;\\n    function withdrawInvoice(uint256 tokenId) external;\\n    function getInvoiceCount() external view returns (uint256);\\n    function getInvoiceTokenId(uint256 index) external view returns (uint256);\\n}\",\"keccak256\":\"0xb291b531707b70d8ca8a7a299d06518a95e53ac2a9e969d091f13fc0c38bf2ef\",\"license\":\"MIT\"},\"contracts/interfaces/IMarketplace.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nstruct MarketItem {\\n    address nftContract;\\n    uint256 tokenId;\\n    address seller;\\n    address owner;\\n    uint256 price;\\n    bool sold;\\n    address receiver;\\n    address paymentToken;\\n}\\n\\ninterface IMarketplace {\\n\\n    event Bids(uint256 indexed itemId, address bidder, uint256 amount);\\n    event Sales(address indexed tokenAddress, uint256 indexed tokenId, address indexed owner);\\n\\n    event Listings(\\n        address indexed nftContract,\\n        uint256 indexed tokenId,\\n        address seller,\\n        address receiver,\\n        address owner,\\n        uint256 price,\\n        bool sold,\\n        address paymentToken\\n    );\\n    event Delisted(uint256 indexed itemId);\\n\\n    function listItem(\\n        address nftContract,\\n        address payable receiver,\\n        uint256 tokenId,\\n        uint256 price,\\n        bool transferNFT,\\n        address paymentToken\\n    ) external payable;\\n\\n    function delistItem(address nftContract, uint256 itemId) external;\\n\\n    function purchaseItem(address nftContract, uint256 itemId) external payable;\\n\\n    function fetchItems() external view returns (MarketItem[] memory);\\n\\n    function fetchItem(address nftContract, uint256 tokenId) external view returns (MarketItem memory);\\n\\n}\\n\",\"keccak256\":\"0xac028b4cdffda44437ed4a52e5d16512042dd57f14bdd5d65b5a18e33152de90\",\"license\":\"MIT\"},\"contracts/interfaces/INFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface INFT {\\n    function mint(address to, uint256 tokenId, string memory metadata) external;\\n    function burn(uint256 tokenId) external;\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n    function getMetadata(uint256 tokenId) external view returns (string memory);\\n}\",\"keccak256\":\"0x85b6f25cebd3a3e39101fc19c64f9a475dc9bc59c1d50381446fc96548a2cf96\",\"license\":\"MIT\"},\"contracts/interfaces/ITrustedIssuersRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IClaimIssuer } from \\\"./IClaimIssuer.sol\\\";\\n\\nstruct TrustedIssuer {\\n    address claimIssuer;\\n    uint[] claimTopics;\\n}\\n\\ninterface ITrustedIssuersRegistry {\\n\\n    // events\\n    event TrustedIssuerAdded(address indexed trustedIssuer, uint[] claimTopics);\\n    event TrustedIssuerRemoved(address indexed trustedIssuer);\\n    event ClaimTopicsUpdated(address indexed trustedIssuer, uint[] claimTopics);\\n\\n    // functions\\n    // setters\\n    function addTrustedIssuer(address _trustedIssuer, uint[] calldata _claimTopics) external;\\n    function removeTrustedIssuer(address _trustedIssuer) external;\\n    function updateIssuerClaimTopics(address _trustedIssuer, uint[] calldata _claimTopics) external;\\n\\n    // getters\\n    function getTrustedIssuer(address issuerAddress) external view returns (TrustedIssuer memory);\\n    function getTrustedIssuers() external view returns (TrustedIssuer[] memory);\\n    function isTrustedIssuer(address _issuer) external view returns(bool);\\n    function getTrustedIssuerClaimTopics(address _trustedIssuer) external view returns(uint[] memory);\\n    function hasTrustedIssuerClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);\\n\\n}\",\"keccak256\":\"0xe614225074d3e906995b5730a4d70e0a97aeba0140ab4391e1e5968e8dca7a5d\",\"license\":\"MIT\"},\"contracts/interfaces/IUSDCPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUSDCPool {\\n    function deposit(uint256 amount) external;\\n    function withdraw(uint256 amount) external;\\n    function getBalance() external view returns (uint256);\\n    function distributeInterest() external;\\n}\",\"keccak256\":\"0x3d9b699c7f3efbfc17865e076d0cab7a65243384876bda78cf19595256623b0c\",\"license\":\"MIT\"},\"contracts/interfaces/IVABB.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVABB {\\n    function mint(address to, uint256 amount) external;\\n    function burn(address from, uint256 amount) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5a9c374628a281fd9c9c0ec5a3ae521d4cba29ed45e3c8145548b378c36faf4d\",\"license\":\"MIT\"},\"contracts/interfaces/IVABI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IVABI {\\n    function mint(address to, uint256 amount) external;\\n    function burn(address from, uint256 amount) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\",\"keccak256\":\"0x788db947a177b2b6f1fcbd9d9cf4a98b9efd2fd6dac7fc4b106162884cc3b042\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x490cade6c8c25dc15bd7384ce9a417178223c029e26e70e5983dc0007f7fb6ef\",\"license\":\"MIT\"},\"contracts/libraries/TradeDealLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"../identity/IdentityStorage.sol\\\";\\nimport \\\"./VabbleLib.sol\\\";\\nimport \\\"../interfaces/IVABB.sol\\\";\\nimport \\\"../interfaces/IVABI.sol\\\";\\nimport \\\"../interfaces/IUSDCPool.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC721Permissioned.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../libraries/LibDiamond.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary TradeDealLib {\\n    // These event declarations are temporary until we complete migration\\n    // They'll be removed once we've updated all functions to return event params\\n    // rather than emit events directly\\n    event TradeDealCreated(\\n        uint256 indexed tradeDealId,\\n        string name,\\n        string symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        bool active,\\n        address nftAddress,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    );\\n    event TradeDealUpdated(\\n        uint256 indexed tradeDealId,\\n        string name,\\n        string symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        bool active,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    );\\n    event TradeDealActivated(uint256 indexed tradeDealId);\\n    event TradeDealDeactivated(uint256 indexed tradeDealId);\\n    event TradeDealParticipantAdded(uint256 indexed tradeDealId, address indexed participant);\\n    event TradeDealParticipantRemoved(uint256 indexed tradeDealId, address indexed participant);\\n    event InvoiceDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\\n    event InvoiceWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 indexed tokenId);\\n    event USDCDepositedToTradeDeal(uint256 indexed tradeDealId, uint256 amount);\\n    event USDCWithdrawnFromTradeDeal(uint256 indexed tradeDealId, uint256 amount);\\n    event InterestDistributedForTradeDeal(uint256 indexed tradeDealId, uint256 totalInterest, uint256 invoicePoolInterest, uint256 vabiInterest, uint256 vabiTokensMinted);\\n    event TradeDealRequiredClaimTopicsSet(uint256 indexed tradeDealId, uint256[] claimTopics);\\n    // New events for enhanced functionality\\n    event TradeDealFullyFunded(uint256 indexed tradeDealId, uint256 fundingTarget);\\n    event TradeDealFundingWithdrawn(uint256 indexed tradeDealId, address indexed recipient, uint256 amount);\\n    event TradeDealRepaid(uint256 indexed tradeDealId, address indexed repayer, uint256 amount, bool fullyRepaid);\\n    event VABBTokensRedeemed(uint256 indexed tradeDealId, address indexed redeemer, uint256 vabbAmount, uint256 usdcAmount);\\n    // Trade Deal data structure\\n    struct TradeDeal {\\n        uint256 id;\\n        string name;\\n        string symbol;           // Symbol for the trade deal, used for VABB token\\n        uint256 interestRate;\\n        uint256 vabbToVabiRatio;\\n        bool active;\\n        uint256[] requiredClaimTopics; // Claim topics required for participation\\n        address vabbAddress;     // Address of the VABB token contract for this trade deal\\n        address vabiAddress;     // Address of the VABI token contract for this trade deal\\n        address usdcAddress;     // Address of the USDC token contract for this trade deal\\n    }\\n    \\n    // Extended VabbleStorage to support trade deals\\n    struct TradeDealStorage {\\n        // Trade deal tracking\\n        mapping(uint256 => TradeDeal) tradeDeals;\\n        uint256[] tradeDealIds;\\n        uint256 nextTradeDealId;\\n        \\n        // Per-trade deal mappings\\n        mapping(uint256 => uint256[]) tradeDealInvoices; // Trade deal ID => array of invoice token IDs\\n        mapping(uint256 => uint256) tradeDealUsdcBalances; // Trade deal ID => USDC balance\\n        mapping(uint256 => mapping(address => bool)) tradeDealParticipants; // Trade deal ID => user address => is participant\\n        mapping(uint256 => uint256[]) tradeDealRequiredClaimTopics; // Trade deal ID => array of required claim topics\\n        \\n        // New fields for enhanced functionality\\n        mapping(uint256 => uint256) tradeDealFundingTargets; // Trade deal ID => funding target\\n        mapping(uint256 => bool) tradeDealFundingWithdrawn; // Trade deal ID => whether funding has been withdrawn\\n        mapping(uint256 => uint256) tradeDealRepaidAmounts; // Trade deal ID => amount repaid\\n        mapping(uint256 => uint256) tradeDealTotalDebt; // Trade deal ID => total debt (principal + interest)\\n        \\n        // Track original depositors of invoices\\n        mapping(uint256 => mapping(uint256 => address)) invoiceDepositors; // Trade deal ID => token ID => original depositor\\n    }\\n    \\n    // Return struct for createTradeDeal function\\n    struct CreateTradeDealResult {\\n        uint256 tradeDealId;\\n        string name;\\n        string symbol;\\n        uint256 interestRate;\\n        uint256 vabbToVabiRatio;\\n        bool active;\\n        address nftAddress;\\n        address vabbAddress;\\n        address vabiAddress;\\n        address usdcAddress;\\n        bool hasClaimTopics;\\n        uint256[] requiredClaimTopics;\\n    }\\n    \\n    // Create a new trade deal\\n    function _createTradeDeal(\\n        string memory name,\\n        string memory symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        uint256[] memory requiredClaimTopics,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress,\\n        uint256 fundingTarget\\n    ) internal returns (CreateTradeDealResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        uint256 tradeDealId = tds.nextTradeDealId++;\\n        \\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        tradeDeal.id = tradeDealId;\\n        tradeDeal.name = name;\\n        tradeDeal.symbol = symbol;\\n        tradeDeal.interestRate = interestRate;\\n        tradeDeal.vabbToVabiRatio = vabbToVabiRatio;\\n        tradeDeal.active = true;\\n        \\n        // Check if we should use the VABBTokenFactoryFacet to create a new VABB token\\n        if (vabbAddress == address(0)) {\\n            // Try to create a new VABB token\\n            vabbAddress = _createOrGetVABBToken(tradeDealId, symbol);\\n        }\\n        \\n        tradeDeal.vabbAddress = vabbAddress;\\n        tradeDeal.vabiAddress = vabiAddress;\\n        tradeDeal.usdcAddress = usdcAddress;\\n        \\n        // Set required claim topics\\n        bool hasClaimTopics = requiredClaimTopics.length > 0;\\n        if (hasClaimTopics) {\\n            for (uint256 i = 0; i < requiredClaimTopics.length; i++) {\\n                tradeDeal.requiredClaimTopics.push(requiredClaimTopics[i]);\\n                tds.tradeDealRequiredClaimTopics[tradeDealId].push(requiredClaimTopics[i]);\\n            }\\n        }\\n        \\n        // Set the funding target and initialize repayment tracking\\n        tds.tradeDealFundingTargets[tradeDealId] = fundingTarget;\\n        tds.tradeDealRepaidAmounts[tradeDealId] = 0;\\n        tds.tradeDealTotalDebt[tradeDealId] = 0; // Will be set when fully funded\\n        tds.tradeDealFundingWithdrawn[tradeDealId] = false;\\n        \\n        tds.tradeDealIds.push(tradeDealId);\\n        \\n        // Instead of emitting events, return the data needed for the facet to emit events\\n        CreateTradeDealResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.name = name;\\n        result.symbol = symbol;\\n        result.interestRate = interestRate;\\n        result.vabbToVabiRatio = vabbToVabiRatio;\\n        result.active = true;\\n        result.nftAddress = address(0); // Use address(0) for nftAddress since we're using the Diamond's ERC721PermissionedTokenFacet\\n        result.vabbAddress = vabbAddress;\\n        result.vabiAddress = vabiAddress;\\n        result.usdcAddress = usdcAddress;\\n        result.hasClaimTopics = hasClaimTopics;\\n        result.requiredClaimTopics = requiredClaimTopics;\\n        \\n        return result;\\n    }\\n    // Return struct for updateTradeDeal function\\n    struct UpdateTradeDealResult {\\n        uint256 tradeDealId;\\n        string name;\\n        string symbol;\\n        uint256 interestRate;\\n        uint256 vabbToVabiRatio;\\n        bool active;\\n        address vabbAddress;\\n        address vabiAddress;\\n        address usdcAddress;\\n    }\\n    \\n    // Update an existing trade deal\\n    // Update an existing trade deal\\n    function _updateTradeDeal(\\n        uint256 tradeDealId,\\n        string memory name,\\n        string memory symbol,\\n        uint256 interestRate,\\n        uint256 vabbToVabiRatio,\\n        address vabbAddress,\\n        address vabiAddress,\\n        address usdcAddress\\n    ) internal returns (UpdateTradeDealResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        tradeDeal.name = name;\\n        tradeDeal.symbol = symbol;\\n        tradeDeal.interestRate = interestRate;\\n        tradeDeal.vabbToVabiRatio = vabbToVabiRatio;\\n        tradeDeal.vabbAddress = vabbAddress;\\n        tradeDeal.vabiAddress = vabiAddress;\\n        tradeDeal.usdcAddress = usdcAddress;\\n        \\n        // Instead of emitting an event, return the data needed for the facet to emit the event\\n        UpdateTradeDealResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.name = name;\\n        result.symbol = symbol;\\n        result.interestRate = interestRate;\\n        result.vabbToVabiRatio = vabbToVabiRatio;\\n        result.active = tradeDeal.active;\\n        result.vabbAddress = vabbAddress;\\n        result.vabiAddress = vabiAddress;\\n        result.usdcAddress = usdcAddress;\\n        \\n        return result;\\n    }\\n    \\n    // Return struct for activate/deactivate trade deal\\n    struct TradeDealStateChangeResult {\\n        uint256 tradeDealId;\\n    }\\n    \\n    // Activate a trade deal\\n    function _activateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        tds.tradeDeals[tradeDealId].active = true;\\n        \\n        // Return result instead of emitting event\\n        TradeDealStateChangeResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        return result;\\n    }\\n    \\n    // Deactivate a trade deal\\n    function _deactivateTradeDeal(uint256 tradeDealId) internal returns (TradeDealStateChangeResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        tds.tradeDeals[tradeDealId].active = false;\\n        \\n        // Return result instead of emitting event\\n        TradeDealStateChangeResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        return result;\\n    }\\n    \\n    // Check if a trade deal exists\\n    function _tradeDealExists(uint256 tradeDealId) internal view returns (bool) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        return tradeDealId < tds.nextTradeDealId && tds.tradeDeals[tradeDealId].id == tradeDealId;\\n    }\\n    \\n    // Get trade deal info\\n    function _getTradeDealInfo(uint256 tradeDealId) internal view returns (TradeDeal memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        return tds.tradeDeals[tradeDealId];\\n    }\\n    \\n    // Get all trade deal IDs\\n    function _getAllTradeDealIds() internal view returns (uint256[] memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        return tds.tradeDealIds;\\n    }\\n    \\n    // Return struct for participant management functions\\n    struct TradeDealParticipantResult {\\n        uint256 tradeDealId;\\n        address participant;\\n    }\\n    \\n    // Participant management\\n    function _addTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        tds.tradeDealParticipants[tradeDealId][participant] = true;\\n        \\n        // Return result instead of emitting event\\n        TradeDealParticipantResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.participant = participant;\\n        return result;\\n    }\\n    \\n    function _removeTradeDealParticipant(uint256 tradeDealId, address participant) internal returns (TradeDealParticipantResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        tds.tradeDealParticipants[tradeDealId][participant] = false;\\n        \\n        // Return result instead of emitting event\\n        TradeDealParticipantResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.participant = participant;\\n        return result;\\n    }\\n    \\n    function _isTradeDealParticipant(uint256 tradeDealId, address user) internal view returns (bool) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        // First check if the user is explicitly added as a participant\\n        if (tds.tradeDealParticipants[tradeDealId][user]) {\\n            return true;\\n        }\\n        \\n        // If no required claim topics are set, only explicit participants are allowed\\n        if (tds.tradeDealRequiredClaimTopics[tradeDealId].length == 0) {\\n            return false;\\n        }\\n        \\n        // Check if the user has any of the required claim topics\\n        address identityAddress = ds.identities[user];\\n        if (identityAddress == address(0)) {\\n            return false; // User has no identity\\n        }\\n        \\n        // Get the user's claims\\n        uint256[] storage userClaims = ds.claimList[identityAddress];\\n        \\n        // Check if the user has any of the required claim topics\\n        for (uint256 i = 0; i < tds.tradeDealRequiredClaimTopics[tradeDealId].length; i++) {\\n            uint256 requiredClaimTopic = tds.tradeDealRequiredClaimTopics[tradeDealId][i];\\n            \\n            for (uint256 j = 0; j < userClaims.length; j++) {\\n                if (userClaims[j] == requiredClaimTopic) {\\n                    return true; // User has a required claim\\n                }\\n            }\\n        }\\n        \\n        return false; // User has no required claims\\n    }\\n    \\n    // Return struct for invoice management functions\\n    struct InvoiceActionResult {\\n        uint256 tradeDealId;\\n        uint256 tokenId;\\n    }\\n    \\n    // Invoice management for trade deals\\n    function _depositInvoiceToTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDeals[tradeDealId].active, \\\"Trade deal is not active\\\");\\n        \\n        // Use the Diamond's ERC721PermissionedTokenFacet to transfer the NFT\\n        // This bypasses the need for approval\\n        bytes memory emptyData = \\\"\\\";\\n        IERC721Permissioned(address(this)).forcedTransfer(\\n            msg.sender,\\n            address(this),\\n            tokenId,\\n            emptyData\\n        );\\n        \\n        // Track the invoice in this trade deal\\n        tds.tradeDealInvoices[tradeDealId].push(tokenId);\\n        \\n        // Record the original depositor of this invoice\\n        tds.invoiceDepositors[tradeDealId][tokenId] = msg.sender;\\n        console.log(\\\"Recording original depositor of invoice:\\\", msg.sender);\\n        \\n        // Return result instead of emitting event\\n        InvoiceActionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.tokenId = tokenId;\\n        return result;\\n    }\\n\\n    function _withdrawInvoiceFromTradeDeal(uint256 tradeDealId, uint256 tokenId) internal returns (InvoiceActionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        // Verify that the NFT is owned by this contract\\n        require(IERC721(address(this)).ownerOf(tokenId) == address(this), \\\"NFT not owned by this contract\\\");\\n        \\n        // Check if the caller is the original depositor of this invoice\\n        require(\\n            tds.invoiceDepositors[tradeDealId][tokenId] == msg.sender ||\\n            msg.sender == LibDiamond.contractOwner(),\\n            \\\"Only the original depositor or contract owner can withdraw this invoice\\\"\\n        );\\n        \\n        // Remove the invoice from this trade deal's tracking\\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\\n        bool found = false;\\n        for (uint256 i = 0; i < invoices.length; i++) {\\n            if (invoices[i] == tokenId) {\\n                // Remove by swapping with the last element and popping\\n                invoices[i] = invoices[invoices.length - 1];\\n                invoices.pop();\\n                found = true;\\n                break;\\n            }\\n        }\\n        \\n        require(found, \\\"Invoice not found in this trade deal\\\");\\n        \\n        // Use forcedTransfer to transfer the NFT back to the sender\\n        // This bypasses the need for approval\\n        bytes memory emptyData = \\\"\\\";\\n        IERC721Permissioned(address(this)).forcedTransfer(\\n            address(this),\\n            msg.sender,\\n            tokenId,\\n            emptyData\\n        );\\n        \\n        // Clean up the depositor tracking\\n        delete tds.invoiceDepositors[tradeDealId][tokenId];\\n        \\n        // Return result instead of emitting event\\n        InvoiceActionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.tokenId = tokenId;\\n        return result;\\n    }\\n    \\n    // Return struct for USDC management functions\\n    struct USDCActionResult {\\n        uint256 tradeDealId;\\n        uint256 amount;\\n        bool isFullyFunded;\\n        uint256 fundingTarget;\\n    }\\n    \\n    // USDC management for trade deals\\n    function _depositUSDCToTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDeals[tradeDealId].active, \\\"Trade deal is not active\\\");\\n        \\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        require(tradeDeal.usdcAddress != address(0), \\\"Trade deal USDC address not set\\\");\\n        \\n        // Get funding target and current balance\\n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\\n        uint256 currentBalance = tds.tradeDealUsdcBalances[tradeDealId];\\n        \\n        // If funding target exists, check that deposit won't exceed it\\n        if (fundingTarget > 0) {\\n            uint256 remainingToFund = fundingTarget > currentBalance ?\\n                fundingTarget - currentBalance : 0;\\n                \\n            require(amount <= remainingToFund, \\\"Amount exceeds remaining funding needed\\\");\\n        }\\n        \\n        // Log the depositor address and amount\\n        address depositor = msg.sender;\\n        \\n        // Use the USDC token's transferFrom method to transfer tokens from the sender to this contract\\n        require(IERC20(tradeDeal.usdcAddress).transferFrom(depositor, address(this), amount), \\\"USDC transfer failed\\\");\\n        \\n        // Track the amount in this trade deal\\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\\n        \\n        // Explicitly add the depositor as a participant in the trade deal\\n        // This ensures they can receive VABB tokens\\n        if (!_isTradeDealParticipant(tradeDealId, depositor)) {\\n            _addTradeDealParticipant(tradeDealId, depositor);\\n        }\\n        \\n        // If the trade deal has a VABB token, mint VABB tokens to the depositor\\n        if (tradeDeal.vabbAddress != address(0)) {\\n            // Get the VABB token contract\\n            address vabbToken = tradeDeal.vabbAddress;\\n            \\n            // Force the trade deal to be active during minting\\n            bool wasActive = tradeDeal.active;\\n            tradeDeal.active = true;\\n            \\n            // Try to mint VABB tokens to the depositor\\n            // We need to make sure the depositor is added as a participant first\\n            // This is done by the _addTradeDealParticipant call above\\n            \\n            // Adjust for the difference in decimals between USDC (6) and VABB (18)\\n            // Multiply by 10^12 to convert from USDC decimals to VABB decimals\\n            uint256 adjustedAmount = amount * 1000000000000; // 10^12\\n            \\n            try IVABB(vabbToken).mint(depositor, adjustedAmount) {\\n                // Successfully minted VABB tokens\\n                // Log success for debugging\\n                console.log(\\\"Successfully minted VABB tokens to\\\", depositor);\\n                console.log(\\\"Amount:\\\", adjustedAmount);\\n            } catch {\\n                // Failed to mint VABB tokens, but we'll continue anyway\\n                // This could happen if the VABB token contract doesn't exist or if there's another issue\\n                // We'll continue anyway since the USDC deposit was successful\\n                console.log(\\\"Failed to mint VABB tokens\\\");\\n            }\\n            \\n            // Restore the original active state\\n            tradeDeal.active = wasActive;\\n        }\\n        \\n        // Check if this deposit completes the funding\\n        if (fundingTarget > 0 && currentBalance + amount >= fundingTarget) {\\n            // Calculate total debt including interest\\n            uint256 interest = (fundingTarget * tradeDeal.interestRate) / 10000;\\n            tds.tradeDealTotalDebt[tradeDealId] = fundingTarget + interest;\\n            \\n            // Track if funding was completed for the result\\n        }\\n        \\n        // Return result instead of emitting events\\n        USDCActionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.amount = amount;\\n        result.isFullyFunded = (fundingTarget > 0 && currentBalance + amount >= fundingTarget);\\n        result.fundingTarget = fundingTarget;\\n        return result;\\n    }\\n    \\n    function _withdrawUSDCFromTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (USDCActionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDealUsdcBalances[tradeDealId] >= amount, \\\"Insufficient USDC balance in trade deal\\\");\\n        \\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        require(tradeDeal.usdcAddress != address(0), \\\"Trade deal USDC address not set\\\");\\n        \\n        // Use the USDC token's transfer method to transfer tokens from this contract to the sender\\n        require(IERC20(tradeDeal.usdcAddress).transfer(msg.sender, amount), \\\"USDC transfer failed\\\");\\n        \\n        // Update the amount in this trade deal\\n        tds.tradeDealUsdcBalances[tradeDealId] -= amount;\\n        \\n        // Return result instead of emitting event\\n        USDCActionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.amount = amount;\\n        result.isFullyFunded = false; // Not applicable for withdrawal\\n        result.fundingTarget = 0;     // Not applicable for withdrawal\\n        return result;\\n    }\\n    \\n    // Return struct for interest distribution\\n    struct InterestDistributionResult {\\n        uint256 tradeDealId;\\n        uint256 totalInterest;\\n        uint256 invoicePoolInterest;\\n        uint256 vabiInterest;\\n        uint256 vabiTokensMinted;\\n    }\\n    \\n    // Interest distribution for a specific trade deal\\n    // This function is kept for backward compatibility but is simplified to avoid VABI token complexity\\n    function _distributeInterestForTradeDeal(uint256 tradeDealId) internal returns (InterestDistributionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDeals[tradeDealId].active, \\\"Trade deal is not active\\\");\\n        \\n        // Note: Interest calculation is now handled during funding completion and repayment processes\\n        // This function is maintained for backward compatibility\\n        \\n        // We'll calculate interest but won't do anything with it\\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        uint256 balance = tds.tradeDealUsdcBalances[tradeDealId];\\n        uint256 interest = (balance * tradeDeal.interestRate) / 10000;\\n        \\n        // Return result instead of emitting event\\n        InterestDistributionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.totalInterest = interest;\\n        result.invoicePoolInterest = interest; // All interest goes to the trade deal now\\n        result.vabiInterest = 0;               // No VABI interest\\n        result.vabiTokensMinted = 0;           // No VABI tokens minted\\n        \\n        return result;\\n    }\\n    \\n    // Get USDC balance for a specific trade deal\\n    function _getUSDCBalanceForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        return tds.tradeDealUsdcBalances[tradeDealId];\\n    }\\n    \\n    // Get invoice count for a specific trade deal\\n    function _getInvoiceCountForTradeDeal(uint256 tradeDealId) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        return tds.tradeDealInvoices[tradeDealId].length;\\n    }\\n    \\n    // Get invoice token ID for a specific trade deal\\n    function _getInvoiceTokenIdForTradeDeal(uint256 tradeDealId, uint256 index) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(index < tds.tradeDealInvoices[tradeDealId].length, \\\"Index out of bounds\\\");\\n        \\n        return tds.tradeDealInvoices[tradeDealId][index];\\n    }\\n    \\n    // Redeem VABI tokens for a specific trade deal\\n    // This function is deprecated but kept for backward compatibility\\n    function _redeemVABITokensForTradeDeal(uint256 tradeDealId, uint256 amount) internal {\\n        // This function is deprecated as we no longer use VABI tokens\\n        // Users should use _redeemVABBTokens instead\\n        revert(\\\"Function deprecated. Use redeemVABBTokens instead\\\");\\n    }\\n    \\n    // Return struct for setting required claim topics\\n    struct ClaimTopicsResult {\\n        uint256 tradeDealId;\\n        uint256[] claimTopics;\\n    }\\n    \\n    // Set required claim topics for a trade deal\\n    function _setTradeDealRequiredClaimTopics(uint256 tradeDealId, uint256[] memory claimTopics) internal returns (ClaimTopicsResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        // Clear existing claim topics\\n        delete tds.tradeDealRequiredClaimTopics[tradeDealId];\\n        delete tds.tradeDeals[tradeDealId].requiredClaimTopics;\\n        \\n        // Set new claim topics\\n        for (uint256 i = 0; i < claimTopics.length; i++) {\\n            tds.tradeDealRequiredClaimTopics[tradeDealId].push(claimTopics[i]);\\n            tds.tradeDeals[tradeDealId].requiredClaimTopics.push(claimTopics[i]);\\n        }\\n        \\n        // Return result instead of emitting event\\n        ClaimTopicsResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.claimTopics = claimTopics;\\n        return result;\\n    }\\n    \\n    // Get required claim topics for a trade deal\\n    function _getTradeDealRequiredClaimTopics(uint256 tradeDealId) internal view returns (uint256[] memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        return tds.tradeDealRequiredClaimTopics[tradeDealId];\\n    }\\n    \\n    // Check if a trade deal is fully funded\\n    function _isTradeDealFunded(uint256 tradeDealId) internal view returns (bool) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        uint256 fundingTarget = tds.tradeDealFundingTargets[tradeDealId];\\n        if (fundingTarget == 0) {\\n            return false; // No funding target set\\n        }\\n        \\n        return tds.tradeDealUsdcBalances[tradeDealId] >= fundingTarget;\\n    }\\n    \\n    // Check if a trade deal is fully repaid\\n    function _isTradeDealRepaid(uint256 tradeDealId) internal view returns (bool) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        \\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\\n        if (totalDebt == 0) {\\n            return false; // No debt established yet\\n        }\\n        \\n        return tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt;\\n    }\\n    \\n    // Return struct for funding withdrawal\\n    struct FundingWithdrawalResult {\\n        uint256 tradeDealId;\\n        address recipient;\\n        uint256 amount;\\n    }\\n    \\n    // Allow fundees to withdraw USDC funding\\n    function _withdrawTradeDealFunding(uint256 tradeDealId) internal returns (FundingWithdrawalResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDeals[tradeDealId].active, \\\"Trade deal is not active\\\");\\n        require(_isTradeDealFunded(tradeDealId), \\\"Trade deal is not fully funded\\\");\\n        require(!tds.tradeDealFundingWithdrawn[tradeDealId], \\\"Funding already withdrawn\\\");\\n        \\n        // Verify caller has deposited invoices as collateral\\n        uint256[] storage invoices = tds.tradeDealInvoices[tradeDealId];\\n        require(invoices.length > 0, \\\"No invoices deposited as collateral\\\");\\n        \\n        // Get token addresses\\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        address usdcToken = tradeDeal.usdcAddress;\\n        require(usdcToken != address(0), \\\"Trade deal USDC address not set\\\");\\n        \\n        // Get the funding amount\\n        uint256 fundingAmount = tds.tradeDealFundingTargets[tradeDealId];\\n        \\n        // Mark as withdrawn\\n        tds.tradeDealFundingWithdrawn[tradeDealId] = true;\\n        \\n        // Transfer USDC to the caller\\n        require(IERC20(usdcToken).transfer(msg.sender, fundingAmount), \\\"USDC transfer failed\\\");\\n        \\n        // Update USDC balance\\n        tds.tradeDealUsdcBalances[tradeDealId] -= fundingAmount;\\n        \\n        // Return result instead of emitting event\\n        FundingWithdrawalResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.recipient = msg.sender;\\n        result.amount = fundingAmount;\\n        return result;\\n    }\\n    \\n    // Return struct for debt repayment\\n    struct RepaymentResult {\\n        uint256 tradeDealId;\\n        address repayer;\\n        uint256 amount;\\n        bool fullyRepaid;\\n    }\\n    \\n    // Allow fundees to repay their debt\\n    function _repayTradeDeal(uint256 tradeDealId, uint256 amount) internal returns (RepaymentResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(tds.tradeDeals[tradeDealId].active, \\\"Trade deal is not active\\\");\\n        require(tds.tradeDealFundingWithdrawn[tradeDealId], \\\"Funding not yet withdrawn\\\");\\n        \\n        // Calculate remaining debt\\n        uint256 totalDebt = tds.tradeDealTotalDebt[tradeDealId];\\n        uint256 repaidSoFar = tds.tradeDealRepaidAmounts[tradeDealId];\\n        uint256 remainingDebt = totalDebt > repaidSoFar ? totalDebt - repaidSoFar : 0;\\n        \\n        require(remainingDebt > 0, \\\"No remaining debt to repay\\\");\\n        require(amount <= remainingDebt, \\\"Amount exceeds remaining debt\\\");\\n        \\n        // Get USDC token\\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        address usdcToken = tradeDeal.usdcAddress;\\n        require(usdcToken != address(0), \\\"Trade deal USDC address not set\\\");\\n        \\n        // Transfer USDC from repayer to contract\\n        require(IERC20(usdcToken).transferFrom(msg.sender, address(this), amount), \\\"USDC transfer failed\\\");\\n        \\n        // Update repaid amount\\n        tds.tradeDealRepaidAmounts[tradeDealId] += amount;\\n        \\n        // Update USDC balance\\n        tds.tradeDealUsdcBalances[tradeDealId] += amount;\\n        \\n        // Check if fully repaid\\n        bool fullyRepaid = (tds.tradeDealRepaidAmounts[tradeDealId] >= totalDebt);\\n        \\n        // Return result instead of emitting event\\n        RepaymentResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.repayer = msg.sender;\\n        result.amount = amount;\\n        result.fullyRepaid = fullyRepaid;\\n        return result;\\n    }\\n    \\n    // Return struct for VABB token redemption\\n    struct VABBRedemptionResult {\\n        uint256 tradeDealId;\\n        address redeemer;\\n        uint256 vabbAmount;\\n        uint256 usdcAmount;\\n    }\\n    \\n    // Allow funders to redeem their VABB tokens\\n    function _redeemVABBTokens(uint256 tradeDealId, uint256 vabbAmount) internal returns (VABBRedemptionResult memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        TradeDealStorage storage tds = ds.tradeDealStorage;\\n        \\n        require(_tradeDealExists(tradeDealId), \\\"Trade deal does not exist\\\");\\n        require(_isTradeDealRepaid(tradeDealId), \\\"Trade deal not fully repaid\\\");\\n        \\n        // Get token addresses\\n        TradeDeal storage tradeDeal = tds.tradeDeals[tradeDealId];\\n        address vabbToken = tradeDeal.vabbAddress;\\n        address usdcToken = tradeDeal.usdcAddress;\\n        require(vabbToken != address(0), \\\"VABB token address not set\\\");\\n        require(usdcToken != address(0), \\\"USDC token address not set\\\");\\n        \\n        // Check VABB balance\\n        uint256 vabbBalance = IVABB(vabbToken).balanceOf(msg.sender);\\n        require(vabbBalance >= vabbAmount, \\\"Insufficient VABB balance\\\");\\n        \\n        // Calculate proportional USDC amount\\n        uint256 totalVabbSupply = IVABB(vabbToken).totalSupply();\\n        require(totalVabbSupply > 0, \\\"No VABB tokens in circulation\\\");\\n        \\n        uint256 usdcBalance = tds.tradeDealUsdcBalances[tradeDealId];\\n        uint256 usdcAmount = (usdcBalance * vabbAmount) / totalVabbSupply;\\n        \\n        require(usdcAmount > 0, \\\"Calculated USDC amount is zero\\\");\\n        require(usdcBalance >= usdcAmount, \\\"Insufficient USDC balance in trade deal\\\");\\n        \\n        // Burn VABB tokens\\n        IVABB(vabbToken).burn(msg.sender, vabbAmount);\\n        \\n        // Transfer USDC to redeemer\\n        require(IERC20(usdcToken).transfer(msg.sender, usdcAmount), \\\"USDC transfer failed\\\");\\n        \\n        // Update USDC balance\\n        tds.tradeDealUsdcBalances[tradeDealId] -= usdcAmount;\\n        \\n        // Return result instead of emitting event\\n        VABBRedemptionResult memory result;\\n        result.tradeDealId = tradeDealId;\\n        result.redeemer = msg.sender;\\n        result.vabbAmount = vabbAmount;\\n        result.usdcAmount = usdcAmount;\\n        return result;\\n    }\\n    \\n    // Helper function to create or get a VABB token for a trade deal\\n    function _createOrGetVABBToken(uint256 tradeDealId, string memory symbol) internal returns (address) {\\n        address vabbAddress = address(0);\\n        \\n        // First try to get the VABB token address from the VABBTokenFactoryFacet\\n        (bool checkSuccess, bytes memory checkData) = address(this).staticcall(\\n            abi.encodeWithSignature(\\n                \\\"getVABBTokenAddress(uint256)\\\",\\n                tradeDealId\\n            )\\n        );\\n        \\n        // If the check was successful and returned a non-zero address, use that\\n        if (checkSuccess && checkData.length > 0) {\\n            address existingVabbAddress = abi.decode(checkData, (address));\\n            if (existingVabbAddress != address(0)) {\\n                return existingVabbAddress;\\n            }\\n        }\\n        \\n        // If we still don't have a VABB token address, try to create one\\n        string memory tokenName = string(abi.encodePacked(symbol, \\\"-C\\\"));\\n        string memory tokenSymbol = string(abi.encodePacked(symbol, \\\"-C\\\"));\\n        \\n        // Call the VABBTokenFactoryFacet to create a new VABB token\\n        (bool success, bytes memory data) = address(this).call(\\n            abi.encodeWithSignature(\\n                \\\"createVABBToken(uint256,string,string,bool)\\\",\\n                tradeDealId,\\n                tokenName,\\n                tokenSymbol,\\n                true // Enable restrictions by default\\n            )\\n        );\\n        \\n        // If the call was successful, use the returned token address\\n        if (success && data.length > 0) {\\n            vabbAddress = abi.decode(data, (address));\\n        }\\n        \\n        // If we still don't have a VABB token address, try to get it again\\n        if (vabbAddress == address(0)) {\\n            (bool retrySuccess, bytes memory retryData) = address(this).staticcall(\\n                abi.encodeWithSignature(\\n                    \\\"getVABBTokenAddress(uint256)\\\",\\n                    tradeDealId\\n                )\\n            );\\n            \\n            // If the retry was successful and returned a non-zero address, use that\\n            if (retrySuccess && retryData.length > 0) {\\n                address retryVabbAddress = abi.decode(retryData, (address));\\n                if (retryVabbAddress != address(0)) {\\n                    vabbAddress = retryVabbAddress;\\n                }\\n            }\\n        }\\n        \\n        return vabbAddress;\\n    }\\n}\",\"keccak256\":\"0x662db550616464a97bee169e4960bf59bc6a7be6ca536ac3841a5eb95128f0ee\",\"license\":\"MIT\"},\"contracts/libraries/VabbleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/INFT.sol';\\nimport '../interfaces/IInvoicePool.sol';\\nimport '../interfaces/IVABB.sol';\\nimport '../interfaces/IUSDCPool.sol';\\nimport '../interfaces/IVABI.sol';\\nimport \\\"../identity/IdentityStorage.sol\\\";\\n\\n\\nlibrary VabbleLib {\\n    using IdentitySystemStorage for IdentitySystemStorage.IdentitySystem;\\n\\n    function setNFTContract(address _nftContract) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.nft = _nftContract;\\n    }\\n\\n    function setInvoicePoolContract(address _invoicePoolContract) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.invoicePool = _invoicePoolContract;\\n    }\\n\\n    function setVABBContract(address _vabbContract) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.vabb = _vabbContract;\\n    }\\n\\n    function setUSDCPoolContract(address _usdcPoolContract) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.usdcPool = _usdcPoolContract;\\n    }\\n\\n    function setVABIContract(address _vabiContract) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.vabi = _vabiContract;\\n    }\\n\\n    function setInterestRate(uint256 _interestRate) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.interestRate = _interestRate;\\n    }\\n\\n    function setVabbToVabiRatio(uint256 _vabbToVabiRatio) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        ds.vabbleStorage.vabbToVabiRatio = _vabbToVabiRatio;\\n    }\\n\\n    function mintInvoiceNFT(address _to, uint256 _tokenId, string memory _metadata) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        INFT(ds.vabbleStorage.nft).mint(_to, _tokenId, _metadata);\\n    }\\n\\n    function depositInvoice(uint256 _tokenId) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IInvoicePool(ds.vabbleStorage.invoicePool).depositInvoice(_tokenId);\\n    }\\n\\n    function mintVABBTokens(address _to, uint256 _amount) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IVABB(ds.vabbleStorage.vabb).mint(_to, _amount);\\n    }\\n\\n    function distributeInterest() internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        uint256 interest = IUSDCPool(ds.vabbleStorage.usdcPool).getBalance() * ds.vabbleStorage.interestRate / 10000;\\n        uint256 invoicePoolInterest = interest / 2;\\n        uint256 vabiInterest = interest - invoicePoolInterest;\\n\\n        IUSDCPool(ds.vabbleStorage.usdcPool).withdraw(interest);\\n        IUSDCPool(ds.vabbleStorage.usdcPool).deposit(invoicePoolInterest);\\n\\n        uint256 vabiTokensToMint = vabiInterest * ds.vabbleStorage.vabbToVabiRatio;\\n        IVABI(ds.vabbleStorage.vabi).mint(address(this), vabiTokensToMint);\\n    }\\n\\n    function burnInvoiceNFT(uint256 _tokenId) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        INFT(ds.vabbleStorage.nft).burn(_tokenId);\\n    }\\n\\n    function withdrawInvoice(uint256 _tokenId) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IInvoicePool(ds.vabbleStorage.invoicePool).withdrawInvoice(_tokenId);\\n    }\\n\\n    function getInvoiceCount() internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return IInvoicePool(ds.vabbleStorage.invoicePool).getInvoiceCount();\\n    }\\n\\n    function getInvoiceTokenId(uint256 _index) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return IInvoicePool(ds.vabbleStorage.invoicePool).getInvoiceTokenId(_index);\\n    }\\n\\n    function getVABBBalance(address _account) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return IVABB(ds.vabbleStorage.vabb).balanceOf(_account);\\n    }\\n\\n    function getVABIBalance(address _account) internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return IVABI(ds.vabbleStorage.vabi).balanceOf(_account);\\n    }\\n\\n    function redeemVABITokens(uint256 _amount) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IVABI(ds.vabbleStorage.vabi).burn(msg.sender, _amount);\\n        uint256 usdcAmount = _amount / ds.vabbleStorage.vabbToVabiRatio;\\n        IUSDCPool(ds.vabbleStorage.usdcPool).withdraw(usdcAmount);\\n        payable(msg.sender).transfer(usdcAmount);\\n    }\\n\\n    function getInterestRate() internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return ds.vabbleStorage.interestRate;\\n    }\\n\\n    function getVabbToVabiRatio() internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return ds.vabbleStorage.vabbToVabiRatio;\\n    }\\n\\n    function getInvoiceMetadata(uint256 _tokenId) internal view returns (string memory) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return INFT(ds.vabbleStorage.nft).getMetadata(_tokenId);\\n    }\\n\\n    function getInvoiceOwner(uint256 _tokenId) internal view returns (address) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return INFT(ds.vabbleStorage.nft).ownerOf(_tokenId);\\n    }\\n\\n    function isInvoiceNFTOwner(uint256 _tokenId, address _account) internal view returns (bool) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return INFT(ds.vabbleStorage.nft).ownerOf(_tokenId) == _account;\\n    }\\n\\n    function depositUSDC(uint256 _amount) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IUSDCPool(ds.vabbleStorage.usdcPool).deposit(_amount);\\n    }\\n\\n    function withdrawUSDC(uint256 _amount) internal {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        IUSDCPool(ds.vabbleStorage.usdcPool).withdraw(_amount);\\n    }\\n\\n    function getUSDCBalance() internal view returns (uint256) {\\n        IdentitySystemStorage.IdentitySystem storage ds = IdentitySystemStorage.diamondStorage();\\n        return IUSDCPool(ds.vabbleStorage.usdcPool).getBalance();\\n    }\\n}\",\"keccak256\":\"0x41a28bcda832c82480b123827951f561c0fd79ab1da0306c47e69688deeec357\",\"license\":\"MIT\"},\"contracts/utilities/Modifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"../libraries/LibDiamond.sol\\\";\\n\\ncontract Modifiers {\\n\\n    modifier onlyOwner() {\\n        require(LibDiamond.contractOwner() == msg.sender || address(this) == msg.sender,\\n            \\\"not authorized to call function\\\");\\n        _;\\n    }\\n\\n    function diamondOwner() public view returns (address) {\\n        return LibDiamond.contractOwner();\\n    }\\n\\n}\",\"keccak256\":\"0xe14791f6e81918aeed1b382c07fa11f8885c9f5e95c1eafaf3f1195925e9a2a5\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657613a75908161001c8239f35b600080fdfe6080604052600436101561001257600080fd5b6000803560e01c806313d6b5f61461297b5780631504e3e1146128ba5780631718d7af1461289357806319cc10c0146124845780634b0b57f61461233d5780634c9f67dc14611dd05780634f742606146117945780635a6e71c3146117405780637949ba001461166a5780637d1f54b81461151a5780637d25491514611403578063837e3d02146112305780638dcb9331146112115780638ed5db6614610dfa5780639362285a14610d1f57806397f29d0914610cf65780639ee0770814610c70578063b68f012514610c1c578063d2a6f69c14610807578063e246a8ce14610551578063e3f7cc92146104da578063e4efe117146104a4578063e6ad4611146103e65763ecbf40d91461012557600080fd5b346103e3576020806003193601126103df5760043561014c61014733836130c6565b612c7a565b61015461355d565b5061016661016182612e8d565b612cd2565b8083526000805160206139a08339815191529182815261018f60ff60056040872001541661322d565b610198826134c3565b1561039b578184526000805160206139808339815191529283825260ff60408620541661035a57828552600080516020613960833981519152825260408520541561030957828552815260408420600901546001600160a01b0316906101ff821515613302565b8285526000805160206138e08339815191528152604080862054948252808620805460ff191660011790555163a9059cbb60e01b8152918190839081888161024b8a33600484016133d3565b03925af19182156102fe577f92fd71072fa44ba11968090604eaea2a1d7665490983ea784ab89233ec8f58c6926102899187916102d1575b50613370565b8285526000805160206139e08339815191528152604085206102ac8582546132c0565b90558360406102b961355d565b858152338482015201526040519384523393a3604051f35b6102f19150833d85116102f7575b6102e98183612ac0565b810190613274565b38610283565b503d6102df565b6040513d87823e3d90fd5b60405162461bcd60e51b815260048101839052602360248201527f4e6f20696e766f69636573206465706f736974656420617320636f6c6c6174656044820152621c985b60ea1b6064820152608490fd5b60405162461bcd60e51b8152600481018390526019602482015278233ab73234b7339030b63932b0b23c903bb4ba34323930bbb760391b6044820152606490fd5b6064906040519062461bcd60e51b82526004820152601e60248201527f5472616465206465616c206973206e6f742066756c6c792066756e64656400006044820152fd5b5080fd5b80fd5b50346103e35760203660031901126103e35760043560018060a01b03600080516020613a2083398151915254163314801561049b575b61042590612c2e565b8160405161043281612a40565b5261043f61016182612e8d565b8082526000805160206139a08339815191526020526005604083200160ff1981541690558060405161047081612a40565b52604051907f18a646ad5e9e25d43bd35451aefc591a1c2ec6fc53626bc814c3e5561da5f57b8383a2f35b5030331461041c565b50346103e357806003193601126103e357600080516020613a20833981519152546040516001600160a01b039091168152602090f35b50346103e35760203660031901126103e35761052f6104fa600435612fbe565b602081015190604081015160608201519161053d60a0608083015192015115159260405196879660a0885260a0880190612c09565b908682036020880152612c09565b926040850152606084015260808301520390f35b50346103e35761056036612a2a565b9061056e61014733836130c6565b6105766132cd565b5061058361016182612e8d565b8083526000805160206139a08339815191526020908082526105ae60ff60056040882001541661322d565b828552600080516020613980833981519152825260ff604086205416156107c65782855260008051602061390083398151915282526040852054906000805160206138808339815191529081845260408720548084116000146107bf5761061590846132c0565b801561077d57861161073857848752835260408620600901546001600160a01b0316610642811515613302565b8360405180926323b872dd60e01b8252818a816106648c30336004850161334e565b03925af1801561072d5761067e9188916107165750613370565b838652808352604086206106938682546133b3565b90558386526000805160206139e08339815191528352604086206106b88682546133b3565b9055838652825260408520541015908160606106d26132cd565b858152338482015286604082015201526040519384528301527f910d02d88dc4db903a003bcb42832276104ff07a90c46ad3f5f242549936292360403393a3604051f35b6102f19150853d87116102f7576102e98183612ac0565b6040513d89823e3d90fd5b60405162461bcd60e51b815260048101859052601d60248201527f416d6f756e7420657863656564732072656d61696e696e6720646562740000006044820152606490fd5b60405162461bcd60e51b815260048101869052601a6024820152794e6f2072656d61696e696e67206465627420746f20726570617960301b6044820152606490fd5b5086610615565b60405162461bcd60e51b8152600481018390526019602482015278233ab73234b733903737ba103cb2ba103bb4ba34323930bbb760391b6044820152606490fd5b50346103e35761081636612a2a565b9061082133826130c6565b8015610bfb575b61083190612c7a565b6040519161083e83612a8a565b60008352600060208094015261085661016183612e8d565b6040516331a9108f60e11b8152600481018290526024939081818681305afa908115610a54578691610bba575b506001600160a01b03903090821603610b76578386526000805160206138c083398151915290818352604087208488528352338160408920541614908115610b5b575b5015610ae157838652600080516020613960833981519152825260408620948695875b815480821015610ad45786906108ff8385612df8565b929054600393841b1c1461091d57505061091890612d84565b6108e9565b91909394959697985060001991828101908111610ac1579061095261094561096d9386612df8565b905490871b1c9185612df8565b90919082549060031b600019811b9283911b16911916179055565b81548015610aae578101926109828484612df8565b81939154921b1b191690555560015b15610a5f5750906109c991816040516109a981612a40565b878152604051809581926326aac97560e11b83528833306004860161328c565b038189305af1928315610a54578493610a37575b5084865281526040808620838752825280862080546001600160a01b031916905551610a0881612a8a565b8481520152604051917fa92b2c8f01281ad4d8e4dff3f27cbe455644c050115ef8a0521ed35ab210b3bd8484a3f35b610a4d90833d85116102f7576102e98183612ac0565b50386109dd565b6040513d88823e3d90fd5b826084916040519162461bcd60e51b83526004830152808201527f496e766f696365206e6f7420666f756e6420696e2074686973207472616465206044820152631919585b60e21b6064820152fd5b634e487b7160e01b8a526031600452848afd5b634e487b7160e01b8b526011600452858bfd5b5050509091929394610991565b60405162461bcd60e51b8152600481018390526047818701527f4f6e6c7920746865206f726967696e616c206465706f7369746f72206f72206360448201527f6f6e7472616374206f776e65722063616e207769746864726177207468697320606482015266696e766f69636560c81b608482015260a490fd5b9050600080516020613a2083398151915254163314386108c6565b60405162461bcd60e51b815260048101839052601e818701527f4e4654206e6f74206f776e6564206279207468697320636f6e747261637400006044820152606490fd5b90508181813d8311610bf4575b610bd18183612ac0565b81010312610bf057516001600160a01b0381168103610bf05738610883565b8580fd5b503d610bc7565b50600080516020613a20833981519152546001600160a01b03163314610828565b50346103e35760203660031901126103e357610c606040610c6c92600435610c4661016182612e8d565b81526000805160206138a083398151915260205220612f6f565b60405191829182612bab565b0390f35b50346103e357806003193601126103e35760405160008051602061394083398151915280548083526000918252602080840193927f696bba000635c29ab48970a9bb3a30c259f244f79f191799986d75d3ccbf99f892915b828210610cdf57610c6c85610c6081890382612ac0565b835486529485019460019384019390910190610cc8565b50346103e35760203660031901126103e3576020610d15600435613513565b6040519015158152f35b50346103e3576020806003193601126103df579060e091600435610d4561016182612e8d565b8083526000805160206138e083398151915282526040832054926000805160206139e083398151915283526040812054610d7e836134c3565b838352600080516020613980833981519152855260ff604084205416916000805160206139008339815191528652610dcf604080862054956000805160206138808339815191528952205495613513565b956040519788528701521515604086015215156060850152608084015260a0830152151560c0820152f35b50346103e3576101003660031901126103e3576024356001600160401b0381116103df57610e2c903690600401612afe565b6044356001600160401b03811161120d57610e4b903690600401612afe565b610e536129e8565b610e5b6129fe565b90610e64612a14565b9260018060a01b03600080516020613a20833981519152541633148015611204575b610e8f90612c2e565b610e97612e35565b50610ea6610161600435612e8d565b60043586526000805160206139a08339815191526020526040862085519092906001600160401b03811161114857610ee16001850154612d93565b601f81116111d1575b50806020601f821160011461116757899161115c575b508160011b916000199060031b1c19161760018401555b81516001600160401b03811161114857610f346002850154612d93565b601f811161110a575b506020601f821160011461108857918161105198969492600080516020613a008339815191529896948b9161107d575b508160011b916000199060031b1c19161760028401555b6064359788928360038601556084359283600487015561010060ff6005600789019360018060a01b03169860018060a01b0319948a86825416179055600881019a60018060a01b03169a8b86825416179055600981019b60018060a01b03169b8c8096825416179055610ff5612e35565b986004358a528d60208b01528660408b015260608a01528760808a01520154161515958660a08201528760c08201528860e08201520152611043604051986101008a526101008a0190612c09565b9088820360208a0152612c09565b9760408701526060860152608085015260a084015260c083015260e082015280600435930390a2604051f35b905083015138610f6d565b6002850189526020892090895b601f19841681106110f2575082600080516020613a00833981519152989694926001926110519b999795601f198116106110d9575b5050811b016002840155610f84565b85015160001960f88460031b161c1916905538806110ca565b90916020600181928589015181550193019101611095565b61113890600286018a5260208a20601f840160051c8101916020851061113e575b601f0160051c0190612dcd565b38610f3d565b909150819061112b565b634e487b7160e01b88526041600452602488fd5b905087015138610f00565b91506001850189526020892089925b601f19831684106111b9576001935082601f198116106111a0575b5050811b016001840155610f17565b89015160001960f88460031b161c191690553880611191565b89810151825560209384019360019092019101611176565b6111fe90600186018a5260208a20601f840160051c8101916020851061113e57601f0160051c0190612dcd565b38610eea565b50303314610e86565b8280fd5b50346103e35760203660031901126103e3576020610d156004356134c3565b50346103e35761123f36612a2a565b61124933836130c6565b80156113e2575b61125990612c7a565b6112d460405161126881612a8a565b60008152600060208092015261128061016185612e8d565b8385526000805160206139a083398151915281526112a760ff60056040882001541661322d565b806040516112b481612a40565b868152604051809481926326aac97560e11b83528730336004860161328c565b038188305af19182156102fe5783926113c5575b50838552600080516020613960833981519152815261130a8260408720612e10565b8385526000805160206138c083398151915281526040808620838752825280862080546001600160a01b031916331790555161138a9061134981612aa5565b602881527f5265636f7264696e67206f726967696e616c206465706f7369746f72206f6620838201526734b73b37b4b1b29d60c11b604082015233906137fc565b60405161139681612a8a565b8481520152604051917f0b66693e511e1dc453c70056959759d92966a30195684323c1a530209e3e32308484a3f35b6113db90823d84116102f7576102e98183612ac0565b50386112e8565b50600080516020613a20833981519152546001600160a01b03163314611250565b50346103e3576020806003193601126103df577f4ddc37c9b2de1d019f8484c159dcde5663dbe44fecc540fad47b4a608e8e70f260806004359260018060a01b03600080516020613a20833981519152541633148015611511575b61146790612c2e565b61146f61344a565b5061147c61016185612e8d565b8385526000805160206139a08339815191528082526114a460ff60056040892001541661322d565b84865281526127106114d4604087206000805160206139e0833981519152845260036040892054910154906133c0565b0485836114df61344a565b8781528385820152836040820152826060820152015260405191818352820152846040820152846060820152a2604051f35b5030331461145e565b50346103e35760403660031901126103e3576004356024356001600160401b03811161120d5761154e903690600401612b45565b600080516020613a20833981519152546001600160a01b031633148015611661575b61157990612c2e565b611581613485565b5061158e61016183612e8d565b8183526000805160206138a08339815191529160208381526115b26040862061349f565b8185526000805160206139a0833981519152908181526006926115d984604089200161349f565b865b8551811015611629576116249082895287845261160660408a206115ff838a612de4565b5190612e10565b82895284845261161f8660408b20016115ff838a612de4565b612d84565b6115db565b5060008051602061392083398151915261165986808a95611648613485565b868152015260405191829182612bab565b0390a2604051f35b50303314611570565b50346103e35760a03660031901126103e3576004356116876129d2565b506044356001600160a01b03818116929183900361173b5760643581811680910361173b576084359282841680940361173b57600992600080516020613a20833981519152541633148015611732575b6116e090612c2e565b6116ec61016182612e8d565b85526000805160206139a083398151915260205260408520906007820160018060a01b031995868254161790556008820190858254161790550191825416179055604051f35b503033146116d7565b600080fd5b50346103e35760403660031901126103e35761175a6129d2565b50600080516020613a20833981519152546001600160a01b03163314801561178b575b61178690612c2e565b604051f35b5030331461177d565b50346103e3576101203660031901126103e3576004356001600160401b0381116103df576117c6903690600401612afe565b6024356001600160401b03811161120d576117e5903690600401612afe565b6084356001600160401b038111611dcc57611804903690600401612b45565b61180c6129e8565b6118146129fe565b9361181d612a14565b9560018060a01b03600080516020613a20833981519152541633148015611dc3575b61184890612c2e565b8296611852612d1a565b506000805160206138608339815191529687549761186f89612d84565b90558783526000805160206139a08339815191526020526040832088815584519095906001600160401b038111611d07576118ad6001880154612d93565b601f8111611d90575b50806020601f8211600114611d26578691611d1b575b508160011b916000199060031b1c19161760018701555b87516001600160401b038111611d07576119006002880154612d93565b601f8111611cd4575b50806020601f8211600114611c69578691611c5e575b508160011b916000199060031b1c19161760028701555b6044356003870155606435600487015560058601805460ff191660011790556001600160a01b031615611c4c575b6007850180546001600160a01b038b81166001600160a01b03199283161790925560088701805484841690831617905560098701805492851692909116919091179055855115159485611be2575b508783526000805160206138e08339815191526020526101043560408420556000805160206138808339815191526020528260408120556000805160206139008339815191526020528260408120556000805160206139808339815191526020526040832060ff1981541690556000805160206139408339815191525498600160401b8a1015611bcc5760018a0180600080516020613940833981519152558a1015611bb657611b3389987fed0366d8af5e5ed4eb6e11fb3853d3ba064a0723f1e824313b66b3bde66455ce98611b26988b60209e6000805160206139408339815191526000528f60002001558760c0611aaa612d1a565b9e8f90815260208c9082015285604082015260443560608201526064356080820152600160a082015201528c60e060018060a01b0387169101528c61010060018060a01b0388169101528c61012060018060a01b0389169101526101408d01526101608c01526040519788976101208952610120890190612c09565b908782038d890152612c09565b604435604087015260643560608701526001608087015260a08601949094526001600160a01b0390811660c086015290811660e0850152166101008301520390a2610140810151611b88575b51604051908152f35b8051600080516020613920833981519152611bae61016084015160405191829182612bab565b0390a2611b7f565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b949183999491989697935b8851811015611c3c5780611c11611c07611c37938c612de4565b5160068a01612e10565b888c526000805160206138a083398151915260205261161f60408d206115ff838d612de4565b611bed565b50919450929791959496386119b2565b9750611c5886886135db565b97611964565b90508901513861191f565b91506002880186526020862086925b8b601f1984168510611cbd57506001935082601f19811610611ca4575b5050811b016002870155611936565b8b015160001960f88460031b161c191690553880611c95565b810151825560209384019360019092019101611c78565b611d019060028901875260208720601f840160051c8101916020851061113e57601f0160051c0190612dcd565b38611909565b634e487b7160e01b85526041600452602485fd5b9050860151386118cc565b91506001880186526020862086925b601f1983168410611d78576001935082601f19811610611d5f575b5050811b0160018701556118e3565b88015160001960f88460031b161c191690553880611d50565b88810151825560209384019360019092019101611d35565b611dbd9060018901875260208720601f840160051c8101916020851061113e57601f0160051c0190612dcd565b386118b6565b5030331461183f565b8380fd5b50346103e357611ddf36612a2a565b90611dea33826130c6565b801561231c575b611dfa90612c7a565b611e026132cd565b50611e0f61016182612e8d565b8083526000805160206139a0833981519152602090808252611e3a60ff60056040882001541661322d565b82855281526040842060098101546001600160a01b03908116611e5e811515613302565b8487526000805160206138e083398151915284526040872054956000805160206139e08339815191529384865260408920549388151595866122a8575b6040516323b872dd60e01b81529488908690818e81611ebf8a30336004850161334e565b03925af194851561229d578a95611edc918d916122865750613370565b888b52875260408a20611ef08482546133b3565b9055611efc33896130c6565b1561221f575b6007820154168061201d575b50848061200a575b611fd0575b50611f246132cd565b9586528486019281845284611fb9575b505050604084019115158252606084019485527fc1b8947c6758630f23bff8bd2780c81fe365b6cdf5372314590ea21245fb808360408551925181519081523386820152a251611f85575b83604051f35b7f61e4e7bdd5b89b0b3b83a8990dae7d759e603f368d2d86454c8f31136a075f3691519251604051908152a2388080611f7f565b611fc5929394506133b3565b101590843880611f34565b612710611fe46003611feb930154856133c0565b04836133b3565b8689526000805160206139008339815191528652604089205538611f1b565b508261201683866133b3565b1015611f16565b925060058101805460ff19600181831617835564e8d4a5100085600019048111861515166122095785028c873b156103e3578c97818c9260405180936340c10f1960e01b82528183816120748a33600484016133d3565b03925af191826121e5575b50509160ff9391849315600014612122576000915081906120f16120ff6040516120a881612a8a565b601a8152794661696c656420746f206d696e74205641424220746f6b656e7360301b848201526040519283918583019563104c13eb60e21b875260248401526044830190612c09565b03601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa505b845416921615151617905538611f0e565b6000916121bb6121cf849361217760405161213c81612aa5565b602281527f5375636365737366756c6c79206d696e746564205641424220746f6b656e73208382015261746f60f01b604082015233906137fc565b6040519361218485612a8a565b600785526620b6b7bab73a1d60c91b82860152604051938492830195632d839cb360e21b8752604060248501526064840190612c09565b90604483015203601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa50612111565b9092506121f59193949950612a5b565b6122055790898c97928e3861207f565b8c80fd5b634e487b7160e01b600052601160045260246000fd5b60008760405161222e81612a8a565b828152015261223f61016189612e8d565b878a526000805160206139c0833981519152875260408a203360005287526040600020600160ff1982541617905560405161227981612a8a565b8881528733910152611f02565b6102f191508a3d8c116102f7576102e98183612ac0565b6040513d8d823e3d90fd5b858a1115612316576122ba868b6132c0565b841115611e9b5760405162461bcd60e51b815260048101899052602760248201527f416d6f756e7420657863656564732072656d61696e696e672066756e64696e67604482015266081b995959195960ca1b6064820152608490fd5b8a6122ba565b50600080516020613a20833981519152546001600160a01b03163314611df1565b50346103e35761234c36612a2a565b600080516020613a20833981519152546001600160a01b039081163314801561247b575b61237990612c2e565b6123816132cd565b5061238e61016184612e8d565b8284526000805160206139e0833981519152916020918383526123b782604088205410156133ee565b8486526000805160206139a08339815191528352600960408720015416926123e0841515613302565b82604051809563a9059cbb60e01b82528189816124018833600484016133d3565b03925af1938415610a54577fa539a9eb6d64ed99d8198bd12034f5b51a1e0a78e730858ba9b30c253c6e966f9461243e9188916107165750613370565b8486528252604085206124528282546132c0565b905584606061245f6132cd565b86815283858201528260408201520152604051908152a2604051f35b50303314612370565b50346103e35761249336612a2a565b9061249c6132cd565b506124a961016182612e8d565b6124b281613513565b15612850578083526000805160206139a083398151915260209081526040842060078101546009909101546001600160a01b03908116929116801561280e5782156127cc576040516370a0823160e01b81523360048201528281602481855afa801561072d578691889161279b575b501061275a576040516318160ddd60e01b8152928284600481855afa93841561072d578794612727575b5083156126e2578487526000805160206139e08339815191529182845260408820549461257888876133c0565b0494851561269d578561258c9110156133ee565b803b1561269957876040518092632770a7eb60e21b82528183816125b48d33600484016133d3565b03925af1801561268e5761267b575b5082604051809263a9059cbb60e01b8252818a816125e58a33600484016133d3565b03925af1801561072d576125ff9188916126645750613370565b8386528152604085206126138382546132c0565b90558160606126206132cd565b858152338482015286604082015201526040519384528301527f55a79e34c5e1d43676669f3001afdbc76ab84e938a325793640f66fe4638d37260403393a3604051f35b6102f19150843d86116102f7576102e98183612ac0565b61268790979197612a5b565b95386125c3565b6040513d8a823e3d90fd5b8780fd5b60405162461bcd60e51b815260048101869052601e60248201527f43616c63756c61746564205553444320616d6f756e74206973207a65726f00006044820152606490fd5b60405162461bcd60e51b815260048101849052601d60248201527f4e6f205641424220746f6b656e7320696e2063697263756c6174696f6e0000006044820152606490fd5b9093508281813d8311612753575b61273f8183612ac0565b8101031261274f5751923861254b565b8680fd5b503d612735565b60405162461bcd60e51b8152600481018390526019602482015278496e73756666696369656e7420564142422062616c616e636560381b6044820152606490fd5b809250848092503d83116127c5575b6127b48183612ac0565b8101031261274f5785905138612521565b503d6127aa565b60405162461bcd60e51b815260048101839052601a6024820152791554d110c81d1bdad95b881859191c995cdcc81b9bdd081cd95d60321b6044820152606490fd5b60405162461bcd60e51b815260048101839052601a60248201527915905090881d1bdad95b881859191c995cdcc81b9bdd081cd95d60321b6044820152606490fd5b60405162461bcd60e51b815260206004820152601b60248201527a151c985919481919585b081b9bdd08199d5b1b1e481c995c185a59602a1b6044820152606490fd5b50346103e35760403660031901126103e3576020610d156128b26129d2565b6004356130c6565b50346103e35760203660031901126103e35760043560018060a01b03600080516020613a20833981519152541633148015612972575b6128f990612c2e565b8160405161290681612a40565b5261291361016182612e8d565b8082526000805160206139a083398151915260205260056040832001600160ff198254161790558060405161294781612a40565b52604051907fbf2b21995a82cd2a31b4577ee5317f810aeeedf94f54f11104d5e8abc79f3f3b8383a2f35b503033146128f0565b50346103e35760203660031901126103e357608061299a600435612fbe565b60e081015161010082015161012090920151604080513081526001600160a01b03938416602082015293831690840152166060820152f35b602435906001600160a01b038216820361173b57565b60a435906001600160a01b038216820361173b57565b60c435906001600160a01b038216820361173b57565b60e435906001600160a01b038216820361173b57565b604090600319011261173b576004359060243590565b602081019081106001600160401b03821117611bcc57604052565b6001600160401b038111611bcc57604052565b61014081019081106001600160401b03821117611bcc57604052565b604081019081106001600160401b03821117611bcc57604052565b606081019081106001600160401b03821117611bcc57604052565b601f909101601f19168101906001600160401b03821190821017611bcc57604052565b6001600160401b038111611bcc57601f01601f191660200190565b81601f8201121561173b57803590612b1582612ae3565b92612b236040519485612ac0565b8284526020838301011161173b57816000926020809301838601378301015290565b9080601f8301121561173b578135906001600160401b038211611bcc578160051b60405193602093612b7985840187612ac0565b8552838086019282010192831161173b578301905b828210612b9c575050505090565b81358152908301908301612b8e565b6020908160408183019282815285518094520193019160005b828110612bd2575050505090565b835185529381019392810192600101612bc4565b60005b838110612bf95750506000910152565b8181015183820152602001612be9565b90602091612c2281518092818552858086019101612be6565b601f01601f1916010190565b15612c3557565b60405162461bcd60e51b815260206004820152601f60248201527f6e6f7420617574686f72697a656420746f2063616c6c2066756e6374696f6e006044820152606490fd5b15612c8157565b60405162461bcd60e51b8152602060048201526024808201527f4e6f742061207061727469636970616e7420696e2074686973207472616465206044820152631919585b60e21b6064820152608490fd5b15612cd957565b60405162461bcd60e51b8152602060048201526019602482015278151c985919481919585b08191bd95cc81b9bdd08195e1a5cdd603a1b6044820152606490fd5b6040519061018082016001600160401b03811183821017611bcc57604052606061016083600080825283602083015283604083015280848301528060808301528060a08301528060c08301528060e083015280610100830152806101208301526101408201520152565b60001981146122095760010190565b90600182811c92168015612dc3575b6020831014612dad57565b634e487b7160e01b600052602260045260246000fd5b91607f1691612da2565b818110612dd8575050565b60008155600101612dcd565b8051821015611bb65760209160051b010190565b8054821015611bb65760005260206000200190600090565b80549190600160401b831015611bcc5782610952916001612e3395018155612df8565b565b6040519061012082016001600160401b03811183821017611bcc576040528161010060009182815260606020820152606060408201528260608201528260808201528260a08201528260c08201528260e08201520152565b6000805160206138608339815191525481109081612ea9575090565b8091506000526000805160206139a08339815191526020526040600020541490565b9060405191826000825492612edf84612d93565b908184526001948581169081600014612f4c5750600114612f09575b5050612e3392500383612ac0565b9093915060005260209081600020936000915b818310612f34575050612e3393508201013880612efb565b85548884018501529485019487945091830191612f1c565b915050612e3394506020925060ff191682840152151560051b8201013880612efb565b9060405191828154918282526020928383019160005283600020936000905b828210612fa457505050612e3392500383612ac0565b855484526001958601958895509381019390910190612f8e565b604051612fca81612a6e565b60406000808352606060208401526060828401528060608401528060808401528060a0840152606060c08401528060e0840152610100938185850152816101208095015261301a61016182612e8d565b81526000805160206139a0833981519152602052209160096040519361303f85612a6e565b8054855261304f60018201612ecb565b602086015261306060028201612ecb565b6040860152600381015460608601526004810154608086015260ff600582015416151560a086015261309460068201612f6f565b60c086015260078101546001600160a01b0390811660e087015260088201548116938601939093520154169082015290565b6130d261016182612e8d565b60008181526000805160206139c0833981519152602090815260408083206001600160a01b03958616808552908352818420549295909260ff16613222578484526000805160206138a08339815191529283875282852054156132185784527fbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd832086528184205416801561320f5783527fbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8324855280832080549495909290845b87865282825283862054811015613204576131ad81858820612df8565b9054600391821b1c90875b8981106131d0575050506131cb90612d84565b613190565b826131db828a612df8565b905490841b1c146131f4576131ef90612d84565b6131b8565b5050505050505050505050600190565b505050505091505090565b50505091505090565b5050505091505090565b505050505050600190565b1561323457565b60405162461bcd60e51b81526020600482015260186024820152775472616465206465616c206973206e6f742061637469766560401b6044820152606490fd5b9081602091031261173b5751801515810361173b5790565b6001600160a01b0391821681529116602082015260408101919091526080606082018190526132bd92910190612c09565b90565b9190820391821161220957565b60405190608082016001600160401b03811183821017611bcc5760405260006060838281528260208201528260408201520152565b1561330957565b60405162461bcd60e51b815260206004820152601f60248201527f5472616465206465616c20555344432061646472657373206e6f7420736574006044820152606490fd5b6001600160a01b03918216815291166020820152604081019190915260600190565b1561337757565b60405162461bcd60e51b81526020600482015260146024820152731554d110c81d1c985b9cd9995c8819985a5b195960621b6044820152606490fd5b9190820180921161220957565b8060001904821181151516612209570290565b6001600160a01b039091168152602081019190915260400190565b156133f557565b60405162461bcd60e51b815260206004820152602760248201527f496e73756666696369656e7420555344432062616c616e636520696e207472616044820152661919481919585b60ca1b6064820152608490fd5b6040519060a082016001600160401b03811183821017611bcc5760405260006080838281528260208201528260408201528260608201520152565b6040519061349282612a8a565b6060602083600081520152565b805460008255806134ae575050565b612e3391600052602060002090810190612dcd565b6134cf61016182612e8d565b6000526000805160206138e0833981519152602052604060002054801561350d576000805160206139e0833981519152602052604060002054101590565b50600090565b61351f61016182612e8d565b600052600080516020613900833981519152602052604060002054801561350d57600080516020613880833981519152602052604060002054101590565b60405190606082016001600160401b03811183821017611bcc5760405260006040838281528260208201520152565b3d156135b7573d9061359d82612ae3565b916135ab6040519384612ac0565b82523d6000602084013e565b606090565b9081602091031261173b57516001600160a01b038116810361173b5790565b60009160405160209184808085850163271a197f60e11b958682528860248201526024815261360981612aa5565b5190305afa61361661358c565b90806137f2575b6137bf575b5080916136d46136e98661369460226040519580518482019061364881878b0184612be6565b88019061366a848a612d4360f01b94858a82015203600281018c52018a612ac0565b61367f60405196879451928391860190612be6565b8201908c820152036002810184520182612ac0565b6040519283916136c28a840196639ead3d4760e01b88528c60248601526080604486015260a4850190612c09565b83810360231901606485015290612c09565b6001608483015203601f198101835282612ac0565b519082305af16136f761358c565b90806137b5575b61378e575b506001600160a01b03928484161561371d575b5050505090565b60009182916040519085820192835260248201526024815261373e81612aa5565b5190305afa61374b61358c565b9080613784575b61375d575b80613716565b8161376e92825183010191016135bc565b168061377c575b8080613757565b905038613775565b5080511515613752565b80519194506001600160a01b03916137ad9190810184019084016135bc565b169238613703565b50805115156136fe565b80516001600160a01b0392506137dc9190810186019086016135bc565b16806137e9578590613622565b94505050505090565b508051151561361d565b60009190829161384c604051809261382d602083019563319af33360e01b8752604060248501526064840190612c09565b6001600160a01b0391909116604483015203601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa5056febd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8337bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833ebd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833bbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8340bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833cbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833fd870e4f0b23e1b6feaf7b25c39f808295f3c1bcd9e7208b3a2fc10b19db802e9bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8336bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8338bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833dbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8335bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833abd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8339481f4c7283b81a95f22f60e167e146a8e25140deba7bc5c5816dfd5268a809cbc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320a2646970667358221220e1c1d342408ccf2232ece79e0ca96366bc0bebb18ec4c65b87f384e1434f02b164736f6c63430008100033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b6000803560e01c806313d6b5f61461297b5780631504e3e1146128ba5780631718d7af1461289357806319cc10c0146124845780634b0b57f61461233d5780634c9f67dc14611dd05780634f742606146117945780635a6e71c3146117405780637949ba001461166a5780637d1f54b81461151a5780637d25491514611403578063837e3d02146112305780638dcb9331146112115780638ed5db6614610dfa5780639362285a14610d1f57806397f29d0914610cf65780639ee0770814610c70578063b68f012514610c1c578063d2a6f69c14610807578063e246a8ce14610551578063e3f7cc92146104da578063e4efe117146104a4578063e6ad4611146103e65763ecbf40d91461012557600080fd5b346103e3576020806003193601126103df5760043561014c61014733836130c6565b612c7a565b61015461355d565b5061016661016182612e8d565b612cd2565b8083526000805160206139a08339815191529182815261018f60ff60056040872001541661322d565b610198826134c3565b1561039b578184526000805160206139808339815191529283825260ff60408620541661035a57828552600080516020613960833981519152825260408520541561030957828552815260408420600901546001600160a01b0316906101ff821515613302565b8285526000805160206138e08339815191528152604080862054948252808620805460ff191660011790555163a9059cbb60e01b8152918190839081888161024b8a33600484016133d3565b03925af19182156102fe577f92fd71072fa44ba11968090604eaea2a1d7665490983ea784ab89233ec8f58c6926102899187916102d1575b50613370565b8285526000805160206139e08339815191528152604085206102ac8582546132c0565b90558360406102b961355d565b858152338482015201526040519384523393a3604051f35b6102f19150833d85116102f7575b6102e98183612ac0565b810190613274565b38610283565b503d6102df565b6040513d87823e3d90fd5b60405162461bcd60e51b815260048101839052602360248201527f4e6f20696e766f69636573206465706f736974656420617320636f6c6c6174656044820152621c985b60ea1b6064820152608490fd5b60405162461bcd60e51b8152600481018390526019602482015278233ab73234b7339030b63932b0b23c903bb4ba34323930bbb760391b6044820152606490fd5b6064906040519062461bcd60e51b82526004820152601e60248201527f5472616465206465616c206973206e6f742066756c6c792066756e64656400006044820152fd5b5080fd5b80fd5b50346103e35760203660031901126103e35760043560018060a01b03600080516020613a2083398151915254163314801561049b575b61042590612c2e565b8160405161043281612a40565b5261043f61016182612e8d565b8082526000805160206139a08339815191526020526005604083200160ff1981541690558060405161047081612a40565b52604051907f18a646ad5e9e25d43bd35451aefc591a1c2ec6fc53626bc814c3e5561da5f57b8383a2f35b5030331461041c565b50346103e357806003193601126103e357600080516020613a20833981519152546040516001600160a01b039091168152602090f35b50346103e35760203660031901126103e35761052f6104fa600435612fbe565b602081015190604081015160608201519161053d60a0608083015192015115159260405196879660a0885260a0880190612c09565b908682036020880152612c09565b926040850152606084015260808301520390f35b50346103e35761056036612a2a565b9061056e61014733836130c6565b6105766132cd565b5061058361016182612e8d565b8083526000805160206139a08339815191526020908082526105ae60ff60056040882001541661322d565b828552600080516020613980833981519152825260ff604086205416156107c65782855260008051602061390083398151915282526040852054906000805160206138808339815191529081845260408720548084116000146107bf5761061590846132c0565b801561077d57861161073857848752835260408620600901546001600160a01b0316610642811515613302565b8360405180926323b872dd60e01b8252818a816106648c30336004850161334e565b03925af1801561072d5761067e9188916107165750613370565b838652808352604086206106938682546133b3565b90558386526000805160206139e08339815191528352604086206106b88682546133b3565b9055838652825260408520541015908160606106d26132cd565b858152338482015286604082015201526040519384528301527f910d02d88dc4db903a003bcb42832276104ff07a90c46ad3f5f242549936292360403393a3604051f35b6102f19150853d87116102f7576102e98183612ac0565b6040513d89823e3d90fd5b60405162461bcd60e51b815260048101859052601d60248201527f416d6f756e7420657863656564732072656d61696e696e6720646562740000006044820152606490fd5b60405162461bcd60e51b815260048101869052601a6024820152794e6f2072656d61696e696e67206465627420746f20726570617960301b6044820152606490fd5b5086610615565b60405162461bcd60e51b8152600481018390526019602482015278233ab73234b733903737ba103cb2ba103bb4ba34323930bbb760391b6044820152606490fd5b50346103e35761081636612a2a565b9061082133826130c6565b8015610bfb575b61083190612c7a565b6040519161083e83612a8a565b60008352600060208094015261085661016183612e8d565b6040516331a9108f60e11b8152600481018290526024939081818681305afa908115610a54578691610bba575b506001600160a01b03903090821603610b76578386526000805160206138c083398151915290818352604087208488528352338160408920541614908115610b5b575b5015610ae157838652600080516020613960833981519152825260408620948695875b815480821015610ad45786906108ff8385612df8565b929054600393841b1c1461091d57505061091890612d84565b6108e9565b91909394959697985060001991828101908111610ac1579061095261094561096d9386612df8565b905490871b1c9185612df8565b90919082549060031b600019811b9283911b16911916179055565b81548015610aae578101926109828484612df8565b81939154921b1b191690555560015b15610a5f5750906109c991816040516109a981612a40565b878152604051809581926326aac97560e11b83528833306004860161328c565b038189305af1928315610a54578493610a37575b5084865281526040808620838752825280862080546001600160a01b031916905551610a0881612a8a565b8481520152604051917fa92b2c8f01281ad4d8e4dff3f27cbe455644c050115ef8a0521ed35ab210b3bd8484a3f35b610a4d90833d85116102f7576102e98183612ac0565b50386109dd565b6040513d88823e3d90fd5b826084916040519162461bcd60e51b83526004830152808201527f496e766f696365206e6f7420666f756e6420696e2074686973207472616465206044820152631919585b60e21b6064820152fd5b634e487b7160e01b8a526031600452848afd5b634e487b7160e01b8b526011600452858bfd5b5050509091929394610991565b60405162461bcd60e51b8152600481018390526047818701527f4f6e6c7920746865206f726967696e616c206465706f7369746f72206f72206360448201527f6f6e7472616374206f776e65722063616e207769746864726177207468697320606482015266696e766f69636560c81b608482015260a490fd5b9050600080516020613a2083398151915254163314386108c6565b60405162461bcd60e51b815260048101839052601e818701527f4e4654206e6f74206f776e6564206279207468697320636f6e747261637400006044820152606490fd5b90508181813d8311610bf4575b610bd18183612ac0565b81010312610bf057516001600160a01b0381168103610bf05738610883565b8580fd5b503d610bc7565b50600080516020613a20833981519152546001600160a01b03163314610828565b50346103e35760203660031901126103e357610c606040610c6c92600435610c4661016182612e8d565b81526000805160206138a083398151915260205220612f6f565b60405191829182612bab565b0390f35b50346103e357806003193601126103e35760405160008051602061394083398151915280548083526000918252602080840193927f696bba000635c29ab48970a9bb3a30c259f244f79f191799986d75d3ccbf99f892915b828210610cdf57610c6c85610c6081890382612ac0565b835486529485019460019384019390910190610cc8565b50346103e35760203660031901126103e3576020610d15600435613513565b6040519015158152f35b50346103e3576020806003193601126103df579060e091600435610d4561016182612e8d565b8083526000805160206138e083398151915282526040832054926000805160206139e083398151915283526040812054610d7e836134c3565b838352600080516020613980833981519152855260ff604084205416916000805160206139008339815191528652610dcf604080862054956000805160206138808339815191528952205495613513565b956040519788528701521515604086015215156060850152608084015260a0830152151560c0820152f35b50346103e3576101003660031901126103e3576024356001600160401b0381116103df57610e2c903690600401612afe565b6044356001600160401b03811161120d57610e4b903690600401612afe565b610e536129e8565b610e5b6129fe565b90610e64612a14565b9260018060a01b03600080516020613a20833981519152541633148015611204575b610e8f90612c2e565b610e97612e35565b50610ea6610161600435612e8d565b60043586526000805160206139a08339815191526020526040862085519092906001600160401b03811161114857610ee16001850154612d93565b601f81116111d1575b50806020601f821160011461116757899161115c575b508160011b916000199060031b1c19161760018401555b81516001600160401b03811161114857610f346002850154612d93565b601f811161110a575b506020601f821160011461108857918161105198969492600080516020613a008339815191529896948b9161107d575b508160011b916000199060031b1c19161760028401555b6064359788928360038601556084359283600487015561010060ff6005600789019360018060a01b03169860018060a01b0319948a86825416179055600881019a60018060a01b03169a8b86825416179055600981019b60018060a01b03169b8c8096825416179055610ff5612e35565b986004358a528d60208b01528660408b015260608a01528760808a01520154161515958660a08201528760c08201528860e08201520152611043604051986101008a526101008a0190612c09565b9088820360208a0152612c09565b9760408701526060860152608085015260a084015260c083015260e082015280600435930390a2604051f35b905083015138610f6d565b6002850189526020892090895b601f19841681106110f2575082600080516020613a00833981519152989694926001926110519b999795601f198116106110d9575b5050811b016002840155610f84565b85015160001960f88460031b161c1916905538806110ca565b90916020600181928589015181550193019101611095565b61113890600286018a5260208a20601f840160051c8101916020851061113e575b601f0160051c0190612dcd565b38610f3d565b909150819061112b565b634e487b7160e01b88526041600452602488fd5b905087015138610f00565b91506001850189526020892089925b601f19831684106111b9576001935082601f198116106111a0575b5050811b016001840155610f17565b89015160001960f88460031b161c191690553880611191565b89810151825560209384019360019092019101611176565b6111fe90600186018a5260208a20601f840160051c8101916020851061113e57601f0160051c0190612dcd565b38610eea565b50303314610e86565b8280fd5b50346103e35760203660031901126103e3576020610d156004356134c3565b50346103e35761123f36612a2a565b61124933836130c6565b80156113e2575b61125990612c7a565b6112d460405161126881612a8a565b60008152600060208092015261128061016185612e8d565b8385526000805160206139a083398151915281526112a760ff60056040882001541661322d565b806040516112b481612a40565b868152604051809481926326aac97560e11b83528730336004860161328c565b038188305af19182156102fe5783926113c5575b50838552600080516020613960833981519152815261130a8260408720612e10565b8385526000805160206138c083398151915281526040808620838752825280862080546001600160a01b031916331790555161138a9061134981612aa5565b602881527f5265636f7264696e67206f726967696e616c206465706f7369746f72206f6620838201526734b73b37b4b1b29d60c11b604082015233906137fc565b60405161139681612a8a565b8481520152604051917f0b66693e511e1dc453c70056959759d92966a30195684323c1a530209e3e32308484a3f35b6113db90823d84116102f7576102e98183612ac0565b50386112e8565b50600080516020613a20833981519152546001600160a01b03163314611250565b50346103e3576020806003193601126103df577f4ddc37c9b2de1d019f8484c159dcde5663dbe44fecc540fad47b4a608e8e70f260806004359260018060a01b03600080516020613a20833981519152541633148015611511575b61146790612c2e565b61146f61344a565b5061147c61016185612e8d565b8385526000805160206139a08339815191528082526114a460ff60056040892001541661322d565b84865281526127106114d4604087206000805160206139e0833981519152845260036040892054910154906133c0565b0485836114df61344a565b8781528385820152836040820152826060820152015260405191818352820152846040820152846060820152a2604051f35b5030331461145e565b50346103e35760403660031901126103e3576004356024356001600160401b03811161120d5761154e903690600401612b45565b600080516020613a20833981519152546001600160a01b031633148015611661575b61157990612c2e565b611581613485565b5061158e61016183612e8d565b8183526000805160206138a08339815191529160208381526115b26040862061349f565b8185526000805160206139a0833981519152908181526006926115d984604089200161349f565b865b8551811015611629576116249082895287845261160660408a206115ff838a612de4565b5190612e10565b82895284845261161f8660408b20016115ff838a612de4565b612d84565b6115db565b5060008051602061392083398151915261165986808a95611648613485565b868152015260405191829182612bab565b0390a2604051f35b50303314611570565b50346103e35760a03660031901126103e3576004356116876129d2565b506044356001600160a01b03818116929183900361173b5760643581811680910361173b576084359282841680940361173b57600992600080516020613a20833981519152541633148015611732575b6116e090612c2e565b6116ec61016182612e8d565b85526000805160206139a083398151915260205260408520906007820160018060a01b031995868254161790556008820190858254161790550191825416179055604051f35b503033146116d7565b600080fd5b50346103e35760403660031901126103e35761175a6129d2565b50600080516020613a20833981519152546001600160a01b03163314801561178b575b61178690612c2e565b604051f35b5030331461177d565b50346103e3576101203660031901126103e3576004356001600160401b0381116103df576117c6903690600401612afe565b6024356001600160401b03811161120d576117e5903690600401612afe565b6084356001600160401b038111611dcc57611804903690600401612b45565b61180c6129e8565b6118146129fe565b9361181d612a14565b9560018060a01b03600080516020613a20833981519152541633148015611dc3575b61184890612c2e565b8296611852612d1a565b506000805160206138608339815191529687549761186f89612d84565b90558783526000805160206139a08339815191526020526040832088815584519095906001600160401b038111611d07576118ad6001880154612d93565b601f8111611d90575b50806020601f8211600114611d26578691611d1b575b508160011b916000199060031b1c19161760018701555b87516001600160401b038111611d07576119006002880154612d93565b601f8111611cd4575b50806020601f8211600114611c69578691611c5e575b508160011b916000199060031b1c19161760028701555b6044356003870155606435600487015560058601805460ff191660011790556001600160a01b031615611c4c575b6007850180546001600160a01b038b81166001600160a01b03199283161790925560088701805484841690831617905560098701805492851692909116919091179055855115159485611be2575b508783526000805160206138e08339815191526020526101043560408420556000805160206138808339815191526020528260408120556000805160206139008339815191526020528260408120556000805160206139808339815191526020526040832060ff1981541690556000805160206139408339815191525498600160401b8a1015611bcc5760018a0180600080516020613940833981519152558a1015611bb657611b3389987fed0366d8af5e5ed4eb6e11fb3853d3ba064a0723f1e824313b66b3bde66455ce98611b26988b60209e6000805160206139408339815191526000528f60002001558760c0611aaa612d1a565b9e8f90815260208c9082015285604082015260443560608201526064356080820152600160a082015201528c60e060018060a01b0387169101528c61010060018060a01b0388169101528c61012060018060a01b0389169101526101408d01526101608c01526040519788976101208952610120890190612c09565b908782038d890152612c09565b604435604087015260643560608701526001608087015260a08601949094526001600160a01b0390811660c086015290811660e0850152166101008301520390a2610140810151611b88575b51604051908152f35b8051600080516020613920833981519152611bae61016084015160405191829182612bab565b0390a2611b7f565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052604160045260246000fd5b949183999491989697935b8851811015611c3c5780611c11611c07611c37938c612de4565b5160068a01612e10565b888c526000805160206138a083398151915260205261161f60408d206115ff838d612de4565b611bed565b50919450929791959496386119b2565b9750611c5886886135db565b97611964565b90508901513861191f565b91506002880186526020862086925b8b601f1984168510611cbd57506001935082601f19811610611ca4575b5050811b016002870155611936565b8b015160001960f88460031b161c191690553880611c95565b810151825560209384019360019092019101611c78565b611d019060028901875260208720601f840160051c8101916020851061113e57601f0160051c0190612dcd565b38611909565b634e487b7160e01b85526041600452602485fd5b9050860151386118cc565b91506001880186526020862086925b601f1983168410611d78576001935082601f19811610611d5f575b5050811b0160018701556118e3565b88015160001960f88460031b161c191690553880611d50565b88810151825560209384019360019092019101611d35565b611dbd9060018901875260208720601f840160051c8101916020851061113e57601f0160051c0190612dcd565b386118b6565b5030331461183f565b8380fd5b50346103e357611ddf36612a2a565b90611dea33826130c6565b801561231c575b611dfa90612c7a565b611e026132cd565b50611e0f61016182612e8d565b8083526000805160206139a0833981519152602090808252611e3a60ff60056040882001541661322d565b82855281526040842060098101546001600160a01b03908116611e5e811515613302565b8487526000805160206138e083398151915284526040872054956000805160206139e08339815191529384865260408920549388151595866122a8575b6040516323b872dd60e01b81529488908690818e81611ebf8a30336004850161334e565b03925af194851561229d578a95611edc918d916122865750613370565b888b52875260408a20611ef08482546133b3565b9055611efc33896130c6565b1561221f575b6007820154168061201d575b50848061200a575b611fd0575b50611f246132cd565b9586528486019281845284611fb9575b505050604084019115158252606084019485527fc1b8947c6758630f23bff8bd2780c81fe365b6cdf5372314590ea21245fb808360408551925181519081523386820152a251611f85575b83604051f35b7f61e4e7bdd5b89b0b3b83a8990dae7d759e603f368d2d86454c8f31136a075f3691519251604051908152a2388080611f7f565b611fc5929394506133b3565b101590843880611f34565b612710611fe46003611feb930154856133c0565b04836133b3565b8689526000805160206139008339815191528652604089205538611f1b565b508261201683866133b3565b1015611f16565b925060058101805460ff19600181831617835564e8d4a5100085600019048111861515166122095785028c873b156103e3578c97818c9260405180936340c10f1960e01b82528183816120748a33600484016133d3565b03925af191826121e5575b50509160ff9391849315600014612122576000915081906120f16120ff6040516120a881612a8a565b601a8152794661696c656420746f206d696e74205641424220746f6b656e7360301b848201526040519283918583019563104c13eb60e21b875260248401526044830190612c09565b03601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa505b845416921615151617905538611f0e565b6000916121bb6121cf849361217760405161213c81612aa5565b602281527f5375636365737366756c6c79206d696e746564205641424220746f6b656e73208382015261746f60f01b604082015233906137fc565b6040519361218485612a8a565b600785526620b6b7bab73a1d60c91b82860152604051938492830195632d839cb360e21b8752604060248501526064840190612c09565b90604483015203601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa50612111565b9092506121f59193949950612a5b565b6122055790898c97928e3861207f565b8c80fd5b634e487b7160e01b600052601160045260246000fd5b60008760405161222e81612a8a565b828152015261223f61016189612e8d565b878a526000805160206139c0833981519152875260408a203360005287526040600020600160ff1982541617905560405161227981612a8a565b8881528733910152611f02565b6102f191508a3d8c116102f7576102e98183612ac0565b6040513d8d823e3d90fd5b858a1115612316576122ba868b6132c0565b841115611e9b5760405162461bcd60e51b815260048101899052602760248201527f416d6f756e7420657863656564732072656d61696e696e672066756e64696e67604482015266081b995959195960ca1b6064820152608490fd5b8a6122ba565b50600080516020613a20833981519152546001600160a01b03163314611df1565b50346103e35761234c36612a2a565b600080516020613a20833981519152546001600160a01b039081163314801561247b575b61237990612c2e565b6123816132cd565b5061238e61016184612e8d565b8284526000805160206139e0833981519152916020918383526123b782604088205410156133ee565b8486526000805160206139a08339815191528352600960408720015416926123e0841515613302565b82604051809563a9059cbb60e01b82528189816124018833600484016133d3565b03925af1938415610a54577fa539a9eb6d64ed99d8198bd12034f5b51a1e0a78e730858ba9b30c253c6e966f9461243e9188916107165750613370565b8486528252604085206124528282546132c0565b905584606061245f6132cd565b86815283858201528260408201520152604051908152a2604051f35b50303314612370565b50346103e35761249336612a2a565b9061249c6132cd565b506124a961016182612e8d565b6124b281613513565b15612850578083526000805160206139a083398151915260209081526040842060078101546009909101546001600160a01b03908116929116801561280e5782156127cc576040516370a0823160e01b81523360048201528281602481855afa801561072d578691889161279b575b501061275a576040516318160ddd60e01b8152928284600481855afa93841561072d578794612727575b5083156126e2578487526000805160206139e08339815191529182845260408820549461257888876133c0565b0494851561269d578561258c9110156133ee565b803b1561269957876040518092632770a7eb60e21b82528183816125b48d33600484016133d3565b03925af1801561268e5761267b575b5082604051809263a9059cbb60e01b8252818a816125e58a33600484016133d3565b03925af1801561072d576125ff9188916126645750613370565b8386528152604085206126138382546132c0565b90558160606126206132cd565b858152338482015286604082015201526040519384528301527f55a79e34c5e1d43676669f3001afdbc76ab84e938a325793640f66fe4638d37260403393a3604051f35b6102f19150843d86116102f7576102e98183612ac0565b61268790979197612a5b565b95386125c3565b6040513d8a823e3d90fd5b8780fd5b60405162461bcd60e51b815260048101869052601e60248201527f43616c63756c61746564205553444320616d6f756e74206973207a65726f00006044820152606490fd5b60405162461bcd60e51b815260048101849052601d60248201527f4e6f205641424220746f6b656e7320696e2063697263756c6174696f6e0000006044820152606490fd5b9093508281813d8311612753575b61273f8183612ac0565b8101031261274f5751923861254b565b8680fd5b503d612735565b60405162461bcd60e51b8152600481018390526019602482015278496e73756666696369656e7420564142422062616c616e636560381b6044820152606490fd5b809250848092503d83116127c5575b6127b48183612ac0565b8101031261274f5785905138612521565b503d6127aa565b60405162461bcd60e51b815260048101839052601a6024820152791554d110c81d1bdad95b881859191c995cdcc81b9bdd081cd95d60321b6044820152606490fd5b60405162461bcd60e51b815260048101839052601a60248201527915905090881d1bdad95b881859191c995cdcc81b9bdd081cd95d60321b6044820152606490fd5b60405162461bcd60e51b815260206004820152601b60248201527a151c985919481919585b081b9bdd08199d5b1b1e481c995c185a59602a1b6044820152606490fd5b50346103e35760403660031901126103e3576020610d156128b26129d2565b6004356130c6565b50346103e35760203660031901126103e35760043560018060a01b03600080516020613a20833981519152541633148015612972575b6128f990612c2e565b8160405161290681612a40565b5261291361016182612e8d565b8082526000805160206139a083398151915260205260056040832001600160ff198254161790558060405161294781612a40565b52604051907fbf2b21995a82cd2a31b4577ee5317f810aeeedf94f54f11104d5e8abc79f3f3b8383a2f35b503033146128f0565b50346103e35760203660031901126103e357608061299a600435612fbe565b60e081015161010082015161012090920151604080513081526001600160a01b03938416602082015293831690840152166060820152f35b602435906001600160a01b038216820361173b57565b60a435906001600160a01b038216820361173b57565b60c435906001600160a01b038216820361173b57565b60e435906001600160a01b038216820361173b57565b604090600319011261173b576004359060243590565b602081019081106001600160401b03821117611bcc57604052565b6001600160401b038111611bcc57604052565b61014081019081106001600160401b03821117611bcc57604052565b604081019081106001600160401b03821117611bcc57604052565b606081019081106001600160401b03821117611bcc57604052565b601f909101601f19168101906001600160401b03821190821017611bcc57604052565b6001600160401b038111611bcc57601f01601f191660200190565b81601f8201121561173b57803590612b1582612ae3565b92612b236040519485612ac0565b8284526020838301011161173b57816000926020809301838601378301015290565b9080601f8301121561173b578135906001600160401b038211611bcc578160051b60405193602093612b7985840187612ac0565b8552838086019282010192831161173b578301905b828210612b9c575050505090565b81358152908301908301612b8e565b6020908160408183019282815285518094520193019160005b828110612bd2575050505090565b835185529381019392810192600101612bc4565b60005b838110612bf95750506000910152565b8181015183820152602001612be9565b90602091612c2281518092818552858086019101612be6565b601f01601f1916010190565b15612c3557565b60405162461bcd60e51b815260206004820152601f60248201527f6e6f7420617574686f72697a656420746f2063616c6c2066756e6374696f6e006044820152606490fd5b15612c8157565b60405162461bcd60e51b8152602060048201526024808201527f4e6f742061207061727469636970616e7420696e2074686973207472616465206044820152631919585b60e21b6064820152608490fd5b15612cd957565b60405162461bcd60e51b8152602060048201526019602482015278151c985919481919585b08191bd95cc81b9bdd08195e1a5cdd603a1b6044820152606490fd5b6040519061018082016001600160401b03811183821017611bcc57604052606061016083600080825283602083015283604083015280848301528060808301528060a08301528060c08301528060e083015280610100830152806101208301526101408201520152565b60001981146122095760010190565b90600182811c92168015612dc3575b6020831014612dad57565b634e487b7160e01b600052602260045260246000fd5b91607f1691612da2565b818110612dd8575050565b60008155600101612dcd565b8051821015611bb65760209160051b010190565b8054821015611bb65760005260206000200190600090565b80549190600160401b831015611bcc5782610952916001612e3395018155612df8565b565b6040519061012082016001600160401b03811183821017611bcc576040528161010060009182815260606020820152606060408201528260608201528260808201528260a08201528260c08201528260e08201520152565b6000805160206138608339815191525481109081612ea9575090565b8091506000526000805160206139a08339815191526020526040600020541490565b9060405191826000825492612edf84612d93565b908184526001948581169081600014612f4c5750600114612f09575b5050612e3392500383612ac0565b9093915060005260209081600020936000915b818310612f34575050612e3393508201013880612efb565b85548884018501529485019487945091830191612f1c565b915050612e3394506020925060ff191682840152151560051b8201013880612efb565b9060405191828154918282526020928383019160005283600020936000905b828210612fa457505050612e3392500383612ac0565b855484526001958601958895509381019390910190612f8e565b604051612fca81612a6e565b60406000808352606060208401526060828401528060608401528060808401528060a0840152606060c08401528060e0840152610100938185850152816101208095015261301a61016182612e8d565b81526000805160206139a0833981519152602052209160096040519361303f85612a6e565b8054855261304f60018201612ecb565b602086015261306060028201612ecb565b6040860152600381015460608601526004810154608086015260ff600582015416151560a086015261309460068201612f6f565b60c086015260078101546001600160a01b0390811660e087015260088201548116938601939093520154169082015290565b6130d261016182612e8d565b60008181526000805160206139c0833981519152602090815260408083206001600160a01b03958616808552908352818420549295909260ff16613222578484526000805160206138a08339815191529283875282852054156132185784527fbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd832086528184205416801561320f5783527fbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8324855280832080549495909290845b87865282825283862054811015613204576131ad81858820612df8565b9054600391821b1c90875b8981106131d0575050506131cb90612d84565b613190565b826131db828a612df8565b905490841b1c146131f4576131ef90612d84565b6131b8565b5050505050505050505050600190565b505050505091505090565b50505091505090565b5050505091505090565b505050505050600190565b1561323457565b60405162461bcd60e51b81526020600482015260186024820152775472616465206465616c206973206e6f742061637469766560401b6044820152606490fd5b9081602091031261173b5751801515810361173b5790565b6001600160a01b0391821681529116602082015260408101919091526080606082018190526132bd92910190612c09565b90565b9190820391821161220957565b60405190608082016001600160401b03811183821017611bcc5760405260006060838281528260208201528260408201520152565b1561330957565b60405162461bcd60e51b815260206004820152601f60248201527f5472616465206465616c20555344432061646472657373206e6f7420736574006044820152606490fd5b6001600160a01b03918216815291166020820152604081019190915260600190565b1561337757565b60405162461bcd60e51b81526020600482015260146024820152731554d110c81d1c985b9cd9995c8819985a5b195960621b6044820152606490fd5b9190820180921161220957565b8060001904821181151516612209570290565b6001600160a01b039091168152602081019190915260400190565b156133f557565b60405162461bcd60e51b815260206004820152602760248201527f496e73756666696369656e7420555344432062616c616e636520696e207472616044820152661919481919585b60ca1b6064820152608490fd5b6040519060a082016001600160401b03811183821017611bcc5760405260006080838281528260208201528260408201528260608201520152565b6040519061349282612a8a565b6060602083600081520152565b805460008255806134ae575050565b612e3391600052602060002090810190612dcd565b6134cf61016182612e8d565b6000526000805160206138e0833981519152602052604060002054801561350d576000805160206139e0833981519152602052604060002054101590565b50600090565b61351f61016182612e8d565b600052600080516020613900833981519152602052604060002054801561350d57600080516020613880833981519152602052604060002054101590565b60405190606082016001600160401b03811183821017611bcc5760405260006040838281528260208201520152565b3d156135b7573d9061359d82612ae3565b916135ab6040519384612ac0565b82523d6000602084013e565b606090565b9081602091031261173b57516001600160a01b038116810361173b5790565b60009160405160209184808085850163271a197f60e11b958682528860248201526024815261360981612aa5565b5190305afa61361661358c565b90806137f2575b6137bf575b5080916136d46136e98661369460226040519580518482019061364881878b0184612be6565b88019061366a848a612d4360f01b94858a82015203600281018c52018a612ac0565b61367f60405196879451928391860190612be6565b8201908c820152036002810184520182612ac0565b6040519283916136c28a840196639ead3d4760e01b88528c60248601526080604486015260a4850190612c09565b83810360231901606485015290612c09565b6001608483015203601f198101835282612ac0565b519082305af16136f761358c565b90806137b5575b61378e575b506001600160a01b03928484161561371d575b5050505090565b60009182916040519085820192835260248201526024815261373e81612aa5565b5190305afa61374b61358c565b9080613784575b61375d575b80613716565b8161376e92825183010191016135bc565b168061377c575b8080613757565b905038613775565b5080511515613752565b80519194506001600160a01b03916137ad9190810184019084016135bc565b169238613703565b50805115156136fe565b80516001600160a01b0392506137dc9190810186019086016135bc565b16806137e9578590613622565b94505050505090565b508051151561361d565b60009190829161384c604051809261382d602083019563319af33360e01b8752604060248501526064840190612c09565b6001600160a01b0391909116604483015203601f198101835282612ac0565b51906a636f6e736f6c652e6c6f675afa5056febd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8337bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833ebd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833bbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8340bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833cbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833fd870e4f0b23e1b6feaf7b25c39f808295f3c1bcd9e7208b3a2fc10b19db802e9bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8336bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8338bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833dbd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8335bd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd833abd516eb36b5d4489adb2e717e7d0ce56c1b814eda85e78ad9d8f240b24dd8339481f4c7283b81a95f22f60e167e146a8e25140deba7bc5c5816dfd5268a809cbc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320a2646970667358221220e1c1d342408ccf2232ece79e0ca96366bc0bebb18ec4c65b87f384e1434f02b164736f6c63430008100033",
  "libraries": {
    "AddressSet": "0x53BD8FBbceF4DA0CBf58a6C0f0f2a69B90ade658",
    "AttributeLib": "0x4311717618115bF98c8b6Fb1584986ef8854d661",
    "Base64": "0x3D3b170BaB5117c9c264BcE21557C9105A9DbCDb",
    "Bytes32Set": "0x5659a4609F86Bf68f84490Ff60317C9f289DbAB6",
    "CarbonCreditLib": "0x3e820f20A0638c9Fc703A58dF91E3217a713Bd7C",
    "DiamondFactoryLib": "0x04630F96879C650a1A866aFd8Fa33ef9A0AFd562",
    "DiamondLib": "0xbBEaf36519ad0314b48c2bC5FEAc0e3C90852471",
    "ERC721AEnumerationLib": "0x9D1908913362E0A4666e801b4e8816D93E895D20",
    "ERC721ALib": "0xBb272144eb7784429c1917C7fd8CFAbe16795e7B",
    "Identity": "0x91537c970B08efAB037FbC62aB124eE53558b32d",
    "IdentityFactory": "0x57e00AdC042243560E677413e8BA3fAAfC001875",
    "IdentitySystemStorage": "0x594925E46Ae407408f02EA0486858e1d9E72b391",
    "LibDiamond": "0x573CD8F769E707c61d0467f857518Dfe2C4C1758",
    "MerkleProver": "0x7C2D2b4EB370eD8Fd8349D9Db098Fc792B38a266",
    "MetadataLib": "0xD9CD006e443558277DE983B7BA4A41daFfD5237C",
    "MultiSaleLib": "0x051977FcDF9F8a6E5cAEb695bE88036edD99369c",
    "Strings": "0xCaf28cd397fc9ceF7D9FEd950e41ff675Da582d0",
    "StringsLib": "0x0e6837132cF362Ad22F2c0B762968491f43d8dC8",
    "SVGTemplatesLib": "0x1dC038686c74e6F22e174399fAc9069E3988b901",
    "UInt256Set": "0x6d2ea27213dF404c3bF876E27314321e7005c4D8",
    "VariablePriceLib": "0x991B5d0B7C09661ed70EbBe12a879540FfC77B21"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}